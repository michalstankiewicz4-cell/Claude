<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Petrie Dish v2.22.0 - RANGE SLIDERS: Life Scanner z zakresami!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Rajdhani:wght@500;600&display=swap" rel="stylesheet">
    <style>
/*  
===========================================================
   PETRIE DISH v2.22.0 â€” RANGE SLIDERS EDITION
   âœ… 1000 particles default (3.3x baseline!)
   âœ… Life Scanner: RANGE SLIDERS (from-to)!
   âœ… PARTICLES: 3-100 range (was 3-20)
   âœ… COLORS: 1-16 range, DISTANCE: 5-100px, VELOCITY: 1-10
   âœ… Full control over detection parameters!
===========================================================
*/

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CSS VARIABLES - Global Design Tokens
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
:root {
    /* Kolory mechanik */
    --color-pink: #FF006E;
    --color-cyan: #00F5FF;
    --color-yellow: #FFBE0B;
    --color-purple: #8338EC;
    --color-blue: #3A86FF;
    --color-orange: #FB5607;
    --color-green: #00FF88;
    
    /* Kolory UI */
    --color-text-primary: #8892b0;
    --color-text-bright: #00F5FF;
    --color-bg-dark: rgba(16, 16, 30, 0.6);
    --color-bg-black: #0a0a14;
    --color-border: rgba(131, 56, 236, 0.3);
    --color-border-bright: rgba(131, 56, 236, 0.5);
    
    /* Rozmiary */
    --checkbox-size: 18px;
    --checkbox-border: 2px;
    --slider-height: 6px;
    --slider-thumb-size: 18px;
    --border-radius-small: 3px;
    --border-radius-medium: 6px;
    --border-radius-large: 8px;
    
    /* Spacing */
    --gap-small: 8px;
    --gap-medium: 15px;
    --gap-large: 20px;
    --padding-small: 10px;
    --padding-medium: 15px;
    --padding-large: 20px;
    
    /* Animacje */
    --transition-fast: 0.2s ease;
    --transition-normal: 0.3s ease;
    
    /* Shadows */
    --shadow-glow: 0 0 10px;
    --shadow-neon: 0 0 20px;
    --shadow-strong: 0 0 30px;
}

/* RESET PODSTAWOWY */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* TÅO I GÅÃ“WNY UKÅAD */
body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
    font-family: 'Orbitron', monospace;
    padding: 40px 20px;
}

/* NAGÅÃ“WEK */
h1 {
    font-size: 48px;
    font-weight: 900;
    background: linear-gradient(45deg, #FF006E, #00F5FF, #FFBE0B, #8338EC);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-transform: uppercase;
    letter-spacing: 4px;
    margin-bottom: 10px;
    animation: neonPulse 2s ease-in-out infinite;
    display: flex;
    align-items: baseline;
    gap: 15px;
    justify-content: center;
}

h1 .version {
    font-size: 18px;
    font-weight: 600;
    color: #00F5FF;
    opacity: 0.8;
    letter-spacing: 1px;
    animation: none;
    -webkit-text-fill-color: #00F5FF;
    background: none;
}

/* PODTYTUÅ */
.subtitle {
    color: #8892b0;
    font-size: 14px;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 500;
    letter-spacing: 2px;
    margin-bottom: 30px;
    text-transform: uppercase;
}

/* BLOK ROZMIARÃ“W */
.size-controls {
    border: 1px solid rgba(131, 56, 236, 0.3);
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    animation: slideDown 0.6s ease-out;
    flex-wrap: wrap;
}

.size-controls label {
    color: #8892b0;
    font-size: 12px;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* WSPÃ“LNY STYL INPUTÃ“W NUMERYCZNYCH */
input[type="number"],
.seed-controls input[type="text"],
.seed-controls select {
    padding: 8px 12px;
    background: rgba(0, 0, 0, 0.4);
    border: 2px solid rgba(131, 56, 236, 0.5);
    border-radius: 4px;
    color: #00F5FF;
    font-family: 'Orbitron', monospace;
    font-size: 14px;
    font-weight: 700;
    text-align: center;
    transition: all 0.3s ease;
}

input[type="number"]:focus,
.seed-controls input[type="text"]:focus,
.seed-controls select:focus {
    outline: none;
    border-color: #00F5FF;
    box-shadow: 0 0 15px rgba(0, 245, 255, 0.4);
}

/* SPECYFICZNE SZEROKOÅšCI */
.size-controls input[type="number"] { width: 80px; }
.seed-controls input[type="number"] { width: 100px; }
.seed-controls input[type="text"] { width: 200px; }
.seed-controls select { width: 220px; }

/* SUWAKI â€” SCALONE */
input[type="range"] {
    width: 150px;
    height: 6px; /* poprawiony bÅ‚Ä…d skÅ‚adni */
    background: rgba(0, 0, 0, 0.4);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
}

/* SUWAK â€” THUMB (WEBKIT + MOZ) */
input[type="range"]::-webkit-slider-thumb,
input[type="range"]::-moz-range-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: linear-gradient(135deg, #FF006E, #8338EC);
    border: 2px solid #00F5FF;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
    transition: all 0.3s ease;
}

input[type="range"]::-webkit-slider-thumb:hover,
input[type="range"]::-moz-range-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 20px rgba(0, 245, 255, 0.8);
}

/* WARTOÅšCI SUWAKÃ“W */
.density-value,
.species-value,
.speed-value,
.future-value,
.viscosity-value,
.vorticness-global-value {
    min-width: 45px;
    color: #FFBE0B;
    font-family: 'Orbitron', monospace;
    font-size: 14px;
    font-weight: 700;
    text-align: center;
}

/* INTELLIGENT LIFE KONTROLKI */
.intelligent-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 10px;
}

.intelligent-group input[type="range"] {
    width: 150px;
    height: 6px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
}

.intelligent-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: linear-gradient(135deg, #00F5FF, #3A86FF);
    border: 2px solid #FFBE0B;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
    transition: all 0.3s ease;
}

.intelligent-group input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 20px rgba(0, 245, 255, 0.8);
}

.intelligent-group input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: linear-gradient(135deg, #00F5FF, #3A86FF);
    border: 2px solid #FFBE0B;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
    transition: all 0.3s ease;
}

.intelligent-group input[type="range"]::-moz-range-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 20px rgba(0, 245, 255, 0.8);
}

.intelligent-info {
    display: flex;
    align-items: center;
    margin-top: 10px;
    font-family: 'Orbitron', monospace;
    font-size: 12px;
}

.intelligent-info #intelligentCount {
    color: #FFBE0B;
    font-weight: 700;
}

.intelligent-hint {
    font-family: 'Rajdhani', sans-serif;
    text-align: center;
}

/* PRZYCISK "ZASTOSUJ" */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAÅE BUTTONY - Klasa bazowa
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.btn-small {
    padding: 8px 20px;
    font-size: 12px;
    font-family: 'Orbitron', monospace;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    border: 2px solid;
    border-radius: 4px;
    cursor: pointer;
    transition: all var(--transition-normal);
    box-shadow: 0 0 15px currentColor;
}

.btn-small:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 25px currentColor;
}

.apply-size-btn {
    border-color: var(--color-purple);
    background: linear-gradient(135deg, rgba(131, 56, 236, 0.2), rgba(131, 56, 236, 0.05));
    color: var(--color-purple);
    align-self: center;
    margin-top: 5px;
}

/* BLOK SEEDÃ“W */
.seed-controls {
    border: 1px solid rgba(131, 56, 236, 0.3);
    border-radius: 8px;
    padding: 15px 20px;
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    animation: slideDown 0.7s ease-out 0.1s backwards;
}

.seed-controls .row {
    display: flex;
    align-items: center;
    gap: 15px;
    flex-wrap: wrap;
}

.seed-controls label {
    color: #8892b0;
    font-size: 12px;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* PRZYCISK ÅADOWANIA SEEDU */
.load-seed-btn {
    border-color: var(--color-blue);
    background: linear-gradient(135deg, rgba(58, 134, 255, 0.2), rgba(58, 134, 255, 0.05));
    color: var(--color-blue);
}

/* AKTUALNY SEED */
.current-seed {
    color: #FFBE0B;
    font-family: 'Orbitron', monospace;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 1px;
    max-width: 350px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* CANVAS */
.canvas-container {
    position: relative; /* IMPORTANT: for floating panel */
    border: 3px solid rgba(131, 56, 236, 0.5);
    border-radius: 8px;
    overflow: visible; /* Changed from hidden - allow panel to show */
    box-shadow: 0 0 30px rgba(131, 56, 236, 0.3), 0 0 60px rgba(0, 245, 255, 0.2);
    margin-bottom: 30px;
    animation: slideDown 0.8s ease-out;
}

canvas {
    display: block;
    background: #0a0a14;
}

/* PRZYCISKI GÅÃ“WNE */
.controls {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
    animation: slideDown 1s ease-out 0.2s backwards;
    flex-wrap: wrap;
    justify-content: center;
}

button {
    padding: 14px 32px;
    font-size: 16px;
    font-family: 'Orbitron', monospace;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 2px;
    border: 2px solid;
    border-radius: 6px;
    cursor: pointer;
    transition: all var(--transition-normal);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BUTTONY - Zoptymalizowane z CSS Variables
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#randomizeBtn {
    border-color: var(--color-orange);
    background: linear-gradient(135deg, rgba(251, 86, 7, 0.2), rgba(251, 86, 7, 0.05));
    color: var(--color-orange);
    box-shadow: var(--shadow-neon) rgba(251, 86, 7, 0.3);
}

#startStopBtn {
    border-color: var(--color-cyan);
    background: linear-gradient(135deg, rgba(0, 245, 255, 0.2), rgba(0, 245, 255, 0.05));
    color: var(--color-cyan);
    box-shadow: var(--shadow-neon) rgba(0, 245, 255, 0.3);
}

#startStopBtn.running {
    border-color: var(--color-pink);
    background: linear-gradient(135deg, rgba(255, 0, 110, 0.2), rgba(255, 0, 110, 0.05));
    color: var(--color-pink);
    box-shadow: var(--shadow-neon) rgba(255, 0, 110, 0.3);
}

#resetBtn {
    border-color: var(--color-yellow);
    background: linear-gradient(135deg, rgba(255, 190, 11, 0.2), rgba(255, 190, 11, 0.05));
    color: var(--color-yellow);
    box-shadow: var(--shadow-neon) rgba(255, 190, 11, 0.3);
}

/* HOVER PRZYCISKÃ“W */
button:hover {
    transform: translateY(-2px);
}

#randomizeBtn:hover {
    box-shadow: 0 5px 30px rgba(251, 86, 7, 0.5);
}

#startStopBtn:hover {
    box-shadow: 0 5px 30px rgba(0, 245, 255, 0.5);
}

#startStopBtn.running:hover {
    box-shadow: 0 5px 30px rgba(255, 0, 110, 0.5);
}

#resetBtn:hover {
    box-shadow: 0 5px 30px rgba(255, 190, 11, 0.5);
}

/* LEGENDA â€” BLOK */
.legend {
    border: 1px solid rgba(131, 56, 236, 0.3);
    border-radius: 8px;
    padding: 20px 30px;
    max-width: 320px;
    animation: slideDown 1.2s ease-out 0.4s backwards;
}

.legend h3 {
    color: #00F5FF;
    font-size: 14px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 3px;
    margin-bottom: 15px;
    text-align: center;
}

.legend-content {
    color: #8892b0;
    font-size: 12px;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 500;
    line-height: 1.8;
    letter-spacing: 0.5px;
}

.legend-item {
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.legend-item label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    flex: 1;
}

/* CHECKBOX â€” WSPÃ“LNY */
.legend-item input[type="checkbox"] {
    appearance: none;
    width: 18px;
    height: 18px;
    border: 2px solid;
    border-radius: 3px;
    cursor: pointer;
    position: relative;
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.legend-item input[type="checkbox"]:hover {
    transform: scale(1.1);
}

/* CHECKBOX â€” ZNACZNIK */
.legend-item input[type="checkbox"]:checked::after {
    content: 'âœ“';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 14px;
    font-weight: bold;
}

/* TOOLTIPS â€” IKONKA POMOCY */
.tooltip-icon {
    display: inline-block;
    width: 14px;
    height: 14px;
    line-height: 14px;
    text-align: center;
    font-size: 10px;
    font-weight: 700;
    color: #8892b0;
    background: rgba(136, 146, 176, 0.2);
    border: 1px solid rgba(136, 146, 176, 0.4);
    border-radius: 50%;
    cursor: help;
    margin-left: 5px;
    position: relative;
    transition: all 0.3s ease;
}

.tooltip-icon:hover {
    background: rgba(136, 146, 176, 0.4);
    border-color: #8892b0;
    color: #00F5FF;
    transform: scale(1.1);
}

.tooltip-text {
    visibility: hidden;
    opacity: 0;
    position: absolute;
    left: 50%;
    bottom: 125%;
    transform: translateX(-50%);
    background: rgba(16, 16, 30, 0.98);
    border: 2px solid #8338EC;
    border-radius: 6px;
    padding: 10px 12px;
    width: 280px;
    font-size: 11px;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 500;
    line-height: 1.5;
    color: #8892b0;
    text-align: left;
    z-index: 1000;
    pointer-events: none;
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(131, 56, 236, 0.5);
}

.tooltip-text::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: #8338EC;
}

.tooltip-icon:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
    bottom: 135%;
}

/*  
===========================================================
   LEGENDY â€” KOLORY (ZAMIANA nth-child â†’ KLASY)
===========================================================
*/

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   KLASY KOLORÃ“W - Dla mechanik
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.color-pink { color: var(--color-pink); }
.color-cyan { color: var(--color-cyan); }
.color-yellow { color: var(--color-yellow); }
.color-purple { color: var(--color-purple); }
.color-blue { color: var(--color-blue); }
.color-orange { color: var(--color-orange); }
.color-green { color: var(--color-green); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CHECKBOX BAZOWY - Wszystkie mechaniki
   UÅ¼ywa currentColor z klasy rodzica!
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.mech-attraction input[type="checkbox"],
.mech-charges input[type="checkbox"],
.mech-mass input[type="checkbox"],
.mech-mixing input[type="checkbox"],
.mech-vortex input[type="checkbox"],
.mech-swarm input[type="checkbox"],
.mech-mass-transfer input[type="checkbox"],
.mech-warp input[type="checkbox"],
.mech-bonds input[type="checkbox"],
.mech-intelligent input[type="checkbox"],
.mech-life-detection input[type="checkbox"] {
    appearance: none;
    width: var(--checkbox-size);
    height: var(--checkbox-size);
    border: var(--checkbox-border) solid currentColor;
    border-radius: var(--border-radius-small);
    cursor: pointer;
    position: relative;
    transition: all var(--transition-normal);
    flex-shrink: 0;
}

.mech-attraction input[type="checkbox"]:hover,
.mech-charges input[type="checkbox"]:hover,
.mech-mass input[type="checkbox"]:hover,
.mech-mixing input[type="checkbox"]:hover,
.mech-vortex input[type="checkbox"]:hover,
.mech-swarm input[type="checkbox"]:hover,
.mech-mass-transfer input[type="checkbox"]:hover,
.mech-warp input[type="checkbox"]:hover,
.mech-bonds input[type="checkbox"]:hover,
.mech-intelligent input[type="checkbox"]:hover,
.mech-life-detection input[type="checkbox"]:hover {
    transform: scale(1.1);
}

.mech-attraction input[type="checkbox"]:checked,
.mech-charges input[type="checkbox"]:checked,
.mech-mass input[type="checkbox"]:checked,
.mech-mixing input[type="checkbox"]:checked,
.mech-vortex input[type="checkbox"]:checked,
.mech-swarm input[type="checkbox"]:checked,
.mech-mass-transfer input[type="checkbox"]:checked,
.mech-warp input[type="checkbox"]:checked,
.mech-bonds input[type="checkbox"]:checked,
.mech-intelligent input[type="checkbox"]:checked,
.mech-life-detection input[type="checkbox"]:checked {
    background: color-mix(in srgb, currentColor 30%, transparent);
    box-shadow: var(--shadow-glow) currentColor;
}

.mech-attraction input[type="checkbox"]:checked::after,
.mech-charges input[type="checkbox"]:checked::after,
.mech-mass input[type="checkbox"]:checked::after,
.mech-mixing input[type="checkbox"]:checked::after,
.mech-vortex input[type="checkbox"]:checked::after,
.mech-swarm input[type="checkbox"]:checked::after,
.mech-mass-transfer input[type="checkbox"]:checked::after,
.mech-warp input[type="checkbox"]:checked::after,
.mech-bonds input[type="checkbox"]:checked::after,
.mech-intelligent input[type="checkbox"]:checked::after,
.mech-life-detection input[type="checkbox"]:checked::after {
    content: 'âœ“';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 14px;
    font-weight: bold;
    color: currentColor;
}

/* Kolory dla poszczegÃ³lnych mechanik */
.mech-attraction { color: var(--color-pink); }
.mech-charges { color: var(--color-cyan); }
.mech-mass { color: var(--color-yellow); }
.mech-mixing { color: var(--color-purple); }
.mech-vortex { color: var(--color-orange); }
.mech-swarm { color: var(--color-pink); }
.mech-mass-transfer { color: var(--color-blue); }
.mech-warp { color: var(--color-blue); }
.mech-bonds { color: var(--color-cyan); }
.mech-intelligent { color: var(--color-purple); }
.mech-life-detection { color: var(--color-green); }

/* Opcje mechanik (ukryte domyÅ›lnie) */
.mech-options {
    margin-top: 10px;
    margin-left: 28px;
    padding: 10px;
    background: rgba(131, 56, 236, 0.05);
    border-left: 2px solid rgba(131, 56, 236, 0.3);
    border-radius: 4px;
}

.option-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    font-size: 11px;
}

.option-row label {
    color: #8892b0;
    min-width: 90px;
    cursor: default;
}

.option-row input[type="range"] {
    width: 120px;
    height: 4px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 2px;
    outline: none;
    -webkit-appearance: none;
}

.option-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    background: linear-gradient(135deg, #00F5FF, #3A86FF);
    border: 1px solid #FFBE0B;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 8px rgba(0, 245, 255, 0.4);
}

.option-row input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    background: linear-gradient(135deg, #00F5FF, #3A86FF);
    border: 1px solid #FFBE0B;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 8px rgba(0, 245, 255, 0.4);
}

.option-row input[type="checkbox"] {
    appearance: none;
    width: 14px;
    height: 14px;
    border: 2px solid #00F5FF;
    border-radius: 2px;
    cursor: pointer;
    position: relative;
}

.option-row input[type="checkbox"]:checked {
    background: rgba(0, 245, 255, 0.3);
}

.option-row input[type="checkbox"]:checked::after {
    content: 'âœ“';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 10px;
    color: #00F5FF;
}

.future-value {
    min-width: 30px;
    color: #FFBE0B;
    font-family: 'Orbitron', monospace;
    font-size: 11px;
    font-weight: 700;
    text-align: center;
}

.option-value {
    min-width: 45px;
    color: #FFBE0B;
    font-family: 'Orbitron', monospace;
    font-size: 11px;
    font-weight: 700;
    text-align: center;
}

.option-hint {
    font-size: 10px;
    color: #666;
    margin-top: 5px;
}

.option-hint #intelligentCount {
    color: #FFBE0B;
    font-weight: 700;
}

/* MATRIX EDITOR */
.edit-matrix-btn {
    padding: 6px 12px;
    font-size: 10px;
    font-family: 'Orbitron', monospace;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    border: 1px solid var(--color-purple);
    background: rgba(131, 56, 236, 0.1);
    color: var(--color-purple);
    border-radius: var(--border-radius-small);
    cursor: pointer;
    transition: all var(--transition-normal);
}

.edit-matrix-btn:hover {
    background: rgba(131, 56, 236, 0.2);
    box-shadow: var(--shadow-glow) rgba(131, 56, 236, 0.4);
}

.matrix-container {
    margin-top: 10px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
}

.matrix-hint {
    font-size: 9px;
    color: #888;
    margin-bottom: 8px;
    text-align: center;
}

.interaction-matrix {
    display: grid;
    grid-template-columns: 60px repeat(6, 1fr);
    gap: 3px;
    font-size: 9px;
}

.matrix-cell {
    padding: 6px 4px;
    text-align: center;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 3px;
    min-height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* CORNER CELL (Yâ†“ / Xâ†’) */
.matrix-corner {
    background: rgba(131, 56, 236, 0.15);
    border: 1px solid rgba(131, 56, 236, 0.3);
    font-size: 8px;
    color: #8892b0;
    font-weight: 600;
}

/* COLUMN HEADERS (TO â†’) */
.matrix-header-col {
    background: rgba(0, 245, 255, 0.1);
    border: 1px solid rgba(0, 245, 255, 0.3);
    font-weight: 700;
    flex-direction: column;
}

/* ROW HEADERS (FROM) */
.matrix-header-row {
    background: rgba(255, 190, 11, 0.1);
    border: 1px solid rgba(255, 190, 11, 0.3);
    font-weight: 700;
    flex-direction: column;
}

/* DATA CELLS */
.matrix-data {
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(131, 56, 236, 0.2);
}

.matrix-label {
    font-weight: 700;
    color: #8892b0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.matrix-input {
    width: 100%;
    padding: 3px;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(131, 56, 236, 0.3);
    border-radius: 2px;
    color: #FFBE0B;
    font-family: 'Orbitron', monospace;
    font-size: 10px;
    font-weight: 700;
    text-align: center;
    transition: all 0.2s ease;
}

.matrix-input:focus {
    outline: none;
    border-color: #00F5FF;
    background: rgba(0, 0, 0, 0.8);
    box-shadow: 0 0 8px rgba(0, 245, 255, 0.4);
}

.matrix-input:hover {
    border-color: #8338EC;
}

/* COLOR PROPERTIES TABLE */
.color-properties-table {
    display: table;
    width: 100%;
    border-collapse: collapse;
    font-size: 10px;
    margin-top: 10px;
}

.props-row {
    display: table-row;
}

.props-header {
    display: table-cell;
    padding: 8px 6px;
    background: rgba(131, 56, 236, 0.2);
    border: 1px solid rgba(131, 56, 236, 0.4);
    font-weight: 700;
    color: #00F5FF;
    text-align: center;
    text-transform: uppercase;
    font-size: 9px;
    letter-spacing: 0.5px;
}

.props-cell {
    display: table-cell;
    padding: 8px 6px;
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(131, 56, 236, 0.2);
    text-align: center;
    color: #8892b0;
    font-family: 'Orbitron', monospace;
    font-size: 10px;
}

.props-cell.color-name {
    font-weight: 700;
    text-align: left;
    padding-left: 10px;
}

.props-cell.positive {
    color: #00F5FF;
}

.props-cell.negative {
    color: #FF006E;
}

/* ANIMACJE */
@keyframes neonPulse {
    0%, 100% { 
        filter: hue-rotate(0deg) brightness(1);
        transform: scale(1);
    }
    50% { 
        filter: hue-rotate(15deg) brightness(1.3);
        transform: scale(1.03);
    }
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* ============================================
   LIFE SCANNER - Floating Panel (Futuristic)
   ============================================ */
.life-scanner-panel {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 170px; /* Reduced from 200px */
    background: linear-gradient(135deg, rgba(0, 15, 30, 0.92), rgba(0, 30, 50, 0.92));
    border: 1.5px solid rgba(0, 255, 136, 0.4);
    border-radius: 6px;
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.2), 
                inset 0 0 10px rgba(0, 255, 136, 0.05);
    backdrop-filter: blur(8px);
    font-family: 'Orbitron', monospace;
    z-index: 1000;
    animation: scannerPulse 3s ease-in-out infinite;
}

@keyframes scannerPulse {
    0%, 100% {
        box-shadow: 0 0 30px rgba(0, 255, 136, 0.3), 
                    inset 0 0 20px rgba(0, 255, 136, 0.05);
    }
    50% {
        box-shadow: 0 0 40px rgba(0, 255, 136, 0.5), 
                    inset 0 0 30px rgba(0, 255, 136, 0.1);
    }
}

.scanner-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px; /* Reduced from 10px 15px */
    border-bottom: 1px solid rgba(0, 255, 136, 0.2);
    cursor: pointer;
    transition: background 0.3s ease;
}

.scanner-header:hover {
    background: rgba(0, 255, 136, 0.05);
}

.scanner-title {
    display: flex;
    align-items: center;
    gap: 6px; /* Reduced from 8px */
    color: #00FF88;
    font-size: 10px; /* Reduced from 11px */
    font-weight: 700;
    letter-spacing: 1px; /* Reduced from 1.5px */
    text-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
}

.scanner-icon {
    font-size: 12px; /* Reduced from 14px */
    animation: rotate 4s linear infinite;
}

@keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.scanner-toggle {
    width: 36px; /* Reduced from 40px */
    height: 20px; /* Reduced from 22px */
    background: rgba(0, 0, 0, 0.4);
    border: 1.5px solid rgba(0, 255, 136, 0.3); /* Reduced from 2px */
    border-radius: 10px;
    position: relative;
    cursor: pointer;
    transition: all 0.3s ease;
}

.scanner-toggle:hover {
    border-color: rgba(0, 255, 136, 0.6);
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
}

.scanner-toggle.active {
    background: rgba(0, 255, 136, 0.2);
    border-color: #00FF88;
}

.toggle-dot {
    width: 12px; /* Reduced from 14px */
    height: 12px; /* Reduced from 14px */
    background: #00FF88;
    border-radius: 50%;
    position: absolute;
    top: 2px;
    left: 2px;
    transition: all 0.3s ease;
    box-shadow: 0 0 8px rgba(0, 255, 136, 0.8);
}

.scanner-toggle.active .toggle-dot {
    left: 18px; /* Adjusted from 20px for smaller toggle */
}

.scanner-content {
    padding: 10px; /* Reduced from 12px */
    max-height: 300px; /* Reduced from 350px */
    overflow-y: auto;
}

.scanner-content::-webkit-scrollbar {
    width: 6px;
}

.scanner-content::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
}

.scanner-content::-webkit-scrollbar-thumb {
    background: rgba(0, 255, 136, 0.3);
    border-radius: 3px;
}

.scanner-content::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 255, 136, 0.5);
}

.scanner-status {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(0, 255, 136, 0.2);
    border-radius: 6px;
    margin-bottom: 15px;
}

.status-label {
    color: #8892b0;
    font-size: 11px;
    letter-spacing: 1px;
}

.status-value {
    color: #00FF88;
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 1px;
    text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
}

.scanner-readout {
    background: linear-gradient(135deg, rgba(0, 255, 136, 0.05), rgba(0, 255, 136, 0.02));
    border: 1px solid rgba(0, 255, 136, 0.2);
    border-radius: 6px;
    padding: 10px; /* Reduced from 15px */
    margin-bottom: 12px; /* Reduced from 20px */
}

.readout-item {
    display: flex;
    align-items: baseline;
    gap: 8px;
}

.readout-label {
    color: #8892b0;
    font-size: 10px;
    letter-spacing: 1px;
}

.readout-value {
    color: #00FF88;
    font-size: 18px; /* Reduced from 22px */
    font-weight: 900;
    text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
}

.readout-unit {
    color: #00FF88;
    font-size: 11px;
    letter-spacing: 1px;
    opacity: 0.7;
}

.scanner-controls {
    display: flex;
    flex-direction: column;
    gap: 10px; /* Reduced from 15px */
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 6px; /* Reduced from 8px */
}

.control-label {
    color: #8892b0;
    font-size: 9px; /* Reduced from 10px */
    letter-spacing: 1px; /* Reduced from 1.5px */
    font-weight: 600;
}

.control-input-group {
    display: flex;
    align-items: center;
    gap: 10px;
}

/* RANGE GROUP (dual sliders) */
.control-input-group.range-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.range-separator {
    color: #00FF88;
    font-size: 14px;
    font-weight: 700;
    opacity: 0.6;
    flex-shrink: 0;
    min-width: 20px;
    text-align: center;
}

.range-group .scanner-slider {
    flex: 1;
    min-width: 80px;
}

.scanner-slider {
    flex: 1;
    height: 6px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 3px;
    outline: none;
    -webkit-appearance: none;
    border: 1px solid rgba(0, 255, 136, 0.2);
}

.scanner-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: #00FF88;
    border: 2px solid rgba(0, 255, 136, 0.5);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
    transition: all 0.2s ease;
}

.scanner-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 20px rgba(0, 255, 136, 1);
}

.scanner-slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: #00FF88;
    border: 2px solid rgba(0, 255, 136, 0.5);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
    transition: all 0.2s ease;
}

.scanner-slider::-moz-range-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 20px rgba(0, 255, 136, 1);
}

.control-value {
    min-width: 30px; /* Reduced from 35px */
    color: #00FF88;
    font-size: 11px; /* Reduced from 13px */
    font-weight: 700;
    text-align: right;
    text-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
}

    </style>
</head>
<body>
    <h1>Petrie Dish<span class="version">v2.22.0</span></h1>
    <p class="subtitle">Fluid Dynamics Ã— Particle Life Ã— Magnetic Forces Ã— Spatial Grid</p>

    <div class="seed-controls">
        <div class="row">
            <label for="seedInput">PrÃ³bka:</label>
            <select id="seedSelect">
                <option value="">-- Wybierz prÃ³bkÄ™ --</option>
                <option value="custom">WÅ‚asna prÃ³bka...</option>
                <option value="42">The Answer (42)</option>
                <option value="144714130">Colorful Colonies</option>
                <option value="387363571">Colonies and Vortex</option>
                <option value="882183331">Swarms</option>
                <option value="405382535">Heavy Traffic</option>
                <option value="69129389">From Dot to Chaos</option>
                <option value="143757039">Angry Virus</option>
                <option value="377343605">Blue Planets</option>
                <option value="889271368">Pink and Orange</option>
                <option value="99141546">Fast Life</option>
                <option value="204301394">Medusa</option>
                <option value="820390980">Colony</option>
                <option value="135308335">Going to Boring</option>
                <option value="18731596">Slow But Go</option>
                <option value="67276887">Crazy</option>
                <option value="423640366">They Are Hungry</option>
                <option value="19595201">Hungry But Too Slow</option>
            </select>
            <input type="text" id="seedInput" placeholder="Wpisz numer prÃ³bki" style="display: none;">
            <button id="loadSeedBtn" class="btn-small load-seed-btn" style="display: none;">ZaÅ‚aduj PrÃ³bkÄ™</button>
            <span class="current-seed">Aktualna: <span id="currentSeedDisplay">-</span></span>
        </div>
        
        <div class="row">
            <label for="initModeSelect">Starter czÄ…stek:</label>
            <select id="initModeSelect">
                <option value="random">Losowe (domyÅ›lne)</option>
                <option value="bigbang">Big Bang Theory ğŸ’¥</option>
                <option value="gradient">Mass Gradient > (duÅ¼eâ†’maÅ‚e)</option>
            </select>
        </div>
        
        <div class="row">
            <label for="boundaryModeSelect">Granice:</label>
            <select id="boundaryModeSelect">
                <option value="warp">Warp (torus/obwarzanek)</option>
                <option value="wall">Wall (odbicie od Å›cian)</option>
                <option value="endless">Endless (znikajÄ…) ğŸ’€</option>
            </select>
        </div>
        
        <div class="row">
            <label for="widthInput">SzerokoÅ›Ä‡:</label>
            <input type="number" id="widthInput" value="1000" min="200" max="5000" step="50">
            <label for="heightInput">WysokoÅ›Ä‡:</label>
            <input type="number" id="heightInput" value="500" min="150" max="5000" step="50">
        </div>
        
        <div class="row density-group">
            <label for="densityInput">IloÅ›Ä‡ czÄ…steczek:</label>
            <input type="range" id="densityInput" min="75" max="3000" value="300" step="25">
            <span class="density-value" id="densityValue">300</span>
        </div>
        
        <div class="row species-group">
            <label for="speciesInput">IloÅ›Ä‡ gatunkÃ³w:</label>
            <input type="range" id="speciesInput" min="1" max="15" value="6" step="1">
            <span class="species-value" id="speciesValue">6</span>
        </div>
        
        <button id="applySpeciesBtn" class="btn-small apply-size-btn">Zastosuj</button>
    </div>

    <div class="size-controls">
        <div class="speed-group">
            <label for="speedInput">SzybkoÅ›Ä‡:</label>
            <input type="range" id="speedInput" min="0" max="200" value="100" step="10">
            <span class="speed-value" id="speedValue">100%</span>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="canvas" width="1000" height="500"></canvas>
        
        <!-- LIFE SCANNER - Floating Panel -->
        <div class="life-scanner-panel" id="lifeScannerPanel">
            <div class="scanner-header">
                <div class="scanner-title">
                    <span class="scanner-icon">ğŸ§¬</span>
                    <span>LIFE SCANNER</span>
                </div>
                <div class="scanner-toggle" id="scannerToggle">
                    <div class="toggle-dot"></div>
                </div>
            </div>
            
            <div class="scanner-content" id="scannerContent" style="display: none;">
                <div class="scanner-readout">
                    <div class="readout-item">
                        <span class="readout-label">DETECTED:</span>
                        <span class="readout-value" id="lifeFormsCount">0</span>
                        <span class="readout-unit">FORMS</span>
                    </div>
                </div>
                
                <div class="scanner-controls">
                    <div class="control-group">
                        <label class="control-label">PARTICLES RANGE</label>
                        <div class="control-input-group range-group">
                            <input type="range" id="lifeMinParticlesFrom" min="3" max="100" value="5" step="1" class="scanner-slider">
                            <span class="range-separator">â†’</span>
                            <input type="range" id="lifeMinParticlesTo" min="3" max="100" value="20" step="1" class="scanner-slider">
                            <span class="control-value" id="lifeMinParticlesValue">5-20</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">COLORS RANGE</label>
                        <div class="control-input-group range-group">
                            <input type="range" id="lifeMinColorsFrom" min="1" max="16" value="2" step="1" class="scanner-slider">
                            <span class="range-separator">â†’</span>
                            <input type="range" id="lifeMinColorsTo" min="1" max="16" value="6" step="1" class="scanner-slider">
                            <span class="control-value" id="lifeMinColorsValue">2-6</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">DISTANCE RANGE</label>
                        <div class="control-input-group range-group">
                            <input type="range" id="lifeMaxDistanceFrom" min="5" max="100" value="20" step="1" class="scanner-slider">
                            <span class="range-separator">â†’</span>
                            <input type="range" id="lifeMaxDistanceTo" min="5" max="100" value="50" step="1" class="scanner-slider">
                            <span class="control-value" id="lifeMaxDistanceValue">20-50px</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">VELOCITY RANGE</label>
                        <div class="control-input-group range-group">
                            <input type="range" id="lifeMaxSpeedDiffFrom" min="1" max="10" value="1" step="1" class="scanner-slider">
                            <span class="range-separator">â†’</span>
                            <input type="range" id="lifeMaxSpeedDiffTo" min="1" max="10" value="5" step="1" class="scanner-slider">
                            <span class="control-value" id="lifeMaxSpeedDiffValue">1-5</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="startStopBtn">Start</button>
        <button id="resetBtn">Reset</button>
        <button id="randomizeBtn">Losowa prÃ³bka</button>
    </div>

<div class="legend">
    <h3>Mechanika</h3>
    <div class="legend-content">

        <div class="legend-item mech-attraction">
            <label>
                <input type="checkbox" id="attractionCheckbox" checked>
                <span class="color-dot" style="color: #FF006E;">â—</span>
                <span class="text">PrzyciÄ…ganie/odpychanie kolorÃ³w</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">KaÅ¼da para kolorÃ³w ma siÅ‚Ä™ interakcji z macierzy. WartoÅ›ci dodatnie przyciÄ…gajÄ…, ujemne odpychajÄ…. Edytuj macierz 6x6 klikajÄ…c przycisk poniÅ¼ej!</span>
                </span>
            </label>
            
            <!-- Opcje attraction -->
            <div class="mech-options" id="attractionOptions" style="display: block;">
                <div class="option-row">
                    <label>Strength:</label>
                    <input type="range" id="attractionStrength" min="0" max="200" value="100" step="10">
                    <span class="option-value" id="attractionStrengthValue">100%</span>
                </div>
                <div class="option-row">
                    <button id="editMatrixBtn" class="edit-matrix-btn">ğŸ“Š Edit Interaction Matrix</button>
                    <button id="viewPropertiesBtn" class="edit-matrix-btn" style="margin-left: 10px;">ğŸ¨ View Color Properties</button>
                </div>
                
                <!-- Macierz interakcji (ukryta domyÅ›lnie) -->
                <div id="interactionMatrixContainer" class="matrix-container" style="display: none;">
                    <div class="matrix-hint">ğŸ“Š Wiersz (Yâ†“) = FROM | Kolumna (Xâ†’) = TO | WartoÅ›Ä‡: -1.0 (odpycha) ... 0.0 (neutral) ... +1.0 (przyciÄ…ga)</div>
                    <div id="interactionMatrix" class="interaction-matrix">
                        <!-- Wygenerowane dynamicznie przez JS -->
                    </div>
                </div>
                
                <!-- Color Properties Table (ukryta domyÅ›lnie) -->
                <div id="colorPropertiesContainer" class="matrix-container" style="display: none;">
                    <div class="matrix-hint">ğŸ¨ WÅ‚aÅ›ciwoÅ›ci kaÅ¼dego koloru z seed (read-only - zmieni siÄ™ przy nowym seed)</div>
                    <div id="colorPropertiesTable" class="color-properties-table">
                        <!-- Wygenerowane dynamicznie przez JS -->
                    </div>
                </div>
            </div>
        </div>

        <div class="legend-item mech-charges">
            <label>
                <input type="checkbox" id="chargesCheckbox">
                <span class="color-dot" style="color: #00F5FF;">â—</span>
                <span class="text">Åadunki magnetyczne (+/-)</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">KaÅ¼dy kolor ma Å‚adunek +1 lub -1. Jednakowe Å‚adunki odpychajÄ… siÄ™, przeciwne przyciÄ…gajÄ… (jak magnesy). Tworzy elektryczno-magnetyczne efekty!</span>
                </span>
            </label>
            
            <!-- Opcje charges -->
            <div class="mech-options" id="chargesOptions" style="display: none;">
                <div class="option-row">
                    <label>Force:</label>
                    <input type="range" id="chargeForce" min="0" max="200" value="100" step="10">
                    <span class="option-value" id="chargeForceValue">100%</span>
                </div>
            </div>
        </div>

        <div class="legend-item mech-mass">
            <label>
                <input type="checkbox" id="massCheckbox" checked>
                <span class="color-dot" style="color: #FFBE0B;">â—</span>
                <span class="text">RÃ³Å¼ne masy wpÅ‚ywajÄ… na ruch</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">KaÅ¼dy kolor ma masÄ™ (0.5-1.5). CiÄ™Å¼sze czÄ…stki poruszajÄ… siÄ™ wolniej, lÅ¼ejsze szybciej. Black moÅ¼e byÄ‡ najciÄ™Å¼szy, white najlÅ¼ejszy (z Mass Hierarchy).</span>
                </span>
            </label>
            
            <!-- Opcje mass -->
            <div class="mech-options" id="massOptions" style="display: block;">
                <div class="option-row">
                    <label>Effect:</label>
                    <input type="range" id="massEffect" min="0" max="200" value="100" step="10">
                    <span class="option-value" id="massEffectValue">100%</span>
                </div>
            </div>
        </div>

        <div class="legend-item mech-mass-transfer">
            <label>
                <input type="checkbox" id="massTransferCheckbox">
                <span class="color-dot" style="color: #FFBE0B;">â—</span>
                <span class="text">Mass Transfer - przekaz masy przy zderzeniach</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">Podczas kolizji (<5px) czÄ…stki przekazujÄ… sobie masÄ™. CiÄ™Å¼sze oddajÄ…, lÅ¼ejsze zyskujÄ…. Transfer Rate kontroluje tempo wyrÃ³wnywania mas. Tworzy dynamicznÄ… ewolucjÄ™!</span>
                </span>
            </label>
            
            <!-- Opcje mass transfer -->
            <div class="mech-options" id="massTransferOptions" style="display: none;">
                <div class="option-row">
                    <label>Transfer Rate:</label>
                    <input type="range" id="transferRate" min="0" max="100" value="20" step="5">
                    <span class="option-value" id="transferRateValue">20%</span>
                </div>
            </div>
        </div>

        <div class="legend-item mech-mass-hierarchy">
            <label>
                <input type="checkbox" id="massHierarchyCheckbox">
                <span class="color-dot" style="color: #888888;">â—</span>
                <span class="text">Mass Hierarchy - black najciÄ™Å¼szy, white najlÅ¼ejszy</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">Automatycznie przypisuje masy na podstawie jasnoÅ›ci koloru. Czarne = najciÄ™Å¼sze (1.5-2.0), biaÅ‚e = najlÅ¼ejsze (0.3-0.5). Tworzy naturalne hierarchie!</span>
                </span>
            </label>
            
            <!-- Opcje mass hierarchy -->
            <div class="mech-options" id="massHierarchyOptions" style="display: none;">
                <div class="option-row">
                    <label>Strength:</label>
                    <input type="range" id="hierarchyStrength" min="0" max="200" value="100" step="10">
                    <span class="option-value" id="hierarchyStrengthValue">100%</span>
                </div>
            </div>
        </div>

        <div class="legend-item mech-mixing">
            <label>
                <input type="checkbox" id="mixingCheckbox">
                <span class="color-dot" style="color: #8338EC;">â—</span>
                <span class="text">Mieszanie kolorÃ³w przy zderzeniach</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">Podczas bliskiego kontaktu (<8px) kolory mogÄ… siÄ™ mieszaÄ‡ tworzÄ…c nowe odcienie. WyÅ¼szy Blend Rate = szybsze mieszanie!</span>
                </span>
            </label>
            
            <!-- Opcje mixing -->
            <div class="mech-options" id="mixingOptions" style="display: none;">
                <div class="option-row">
                    <label>Blend Rate:</label>
                    <input type="range" id="blendRate" min="0" max="100" value="20" step="5">
                    <span class="option-value" id="blendRateValue">20%</span>
                </div>
            </div>
        </div>

        <div class="legend-item mech-vortex">
            <label>
                <input type="checkbox" id="vortexCheckbox">
                <span class="color-dot" style="color: #FB5607;">â—</span>
                <span class="text">Vortex - siÅ‚a rotacyjna</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">KaÅ¼dy kolor ma vorticness (0.0-1.0) tworzÄ…cy efekty rotacyjne. CzÄ…stki wirujÄ… wokÃ³Å‚ siebie tworzÄ…c spirale i wiry. WyÅ¼sze vorticness = silniejsze wiry!</span>
                </span>
            </label>
            
            <!-- Opcje vortex -->
            <div class="mech-options" id="vortexOptions" style="display: none;">
                <div class="option-row">
                    <label>Vorticness:</label>
                    <input type="range" id="vorticnessSlider" min="0" max="100" value="50" step="5">
                    <span class="option-value" id="vorticnessValue">50%</span>
                </div>
            </div>
        </div>

        <div class="legend-item mech-swarm">
            <label>
                <input type="checkbox" id="swarmCheckbox">
                <span class="color-dot" style="color: #FF006E;">â—</span>
                <span class="text">Swarm - grupowanie tego samego koloru</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">CzÄ…stki tego samego koloru przyciÄ…gajÄ… siÄ™ do centrum masy swojej grupy. Tworzy zachowania stadne, kolonie i klastry. Range okreÅ›la zasiÄ™g grupowania!</span>
                </span>
            </label>
            
            <!-- Opcje swarm -->
            <div class="mech-options" id="swarmOptions" style="display: none;">
                <div class="option-row">
                    <label>Strength:</label>
                    <input type="range" id="swarmStrength" min="0" max="100" value="50" step="5">
                    <span class="option-value" id="swarmStrengthValue">50%</span>
                </div>
                <div class="option-row">
                    <label>Range:</label>
                    <input type="range" id="swarmRange" min="50" max="200" value="100" step="10">
                    <span class="option-value" id="swarmRangeValue">100px</span>
                </div>
            </div>
        </div>

        <div class="legend-item mech-viscosity">
            <label>
                <input type="checkbox" id="viscosityCheckbox" checked>
                <span class="color-dot" style="color: #3A86FF;">â—</span>
                <span class="text">ğŸ’§ Viscosity - lepkoÅ›Ä‡ przestrzeni</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">OkreÅ›la opÃ³r przestrzeni. 0.90 = energetyczne ruchy, dÅ‚ugie trajektorie. 0.98 = pÅ‚ynne, realistyczne. 0.99 = lepkie, wolne, "underwater". WyÅ‚Ä…czone = czÄ…stki bez oporu!</span>
                </span>
            </label>
            
            <!-- Opcje viscosity -->
            <div class="mech-options" id="viscosityOptions" style="display: block;">
                <div class="option-row">
                    <label>LepkoÅ›Ä‡:</label>
                    <input type="range" id="viscosityInput" min="90" max="99" value="98" step="1">
                    <span class="option-value" id="viscosityValueSpan">0.98</span>
                </div>
                <div class="option-hint">
                    0.90 = energetyczne | 0.98 = pÅ‚ynne | 0.99 = lepkie
                </div>
            </div>
        </div>

        <div class="legend-item mech-intelligent">
            <label>
                <input type="checkbox" id="intelligentCheckbox">
                <span class="color-dot" style="color: #00F5FF;">â—</span>
                <span class="text">ğŸ§  Intelligent Life - czÄ…stki widzÄ… przyszÅ‚oÅ›Ä‡</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">Time-Loop Particles! CzÄ…stki symulujÄ… N krokÃ³w w przyszÅ‚oÅ›Ä‡ i unikajÄ… samych siebie. Prawy przycisk myszy dodaje inteligentnÄ… czÄ…stkÄ™. Future Frames = jak daleko w przyszÅ‚oÅ›Ä‡!</span>
                </span>
            </label>
            
            <!-- Opcje intelligent (ukryte domyÅ›lnie) -->
            <div class="intelligent-options" id="intelligentOptions" style="display: none;">
                <div class="option-row">
                    <label for="futureFramesInput">Future Frames:</label>
                    <input type="range" id="futureFramesInput" min="1" max="30" value="10" step="1">
                    <span class="future-value" id="futureValue">10</span>
                </div>
                <div class="option-row">
                    <label>
                        <input type="checkbox" id="showGhostCheckbox" checked>
                        Show Future Ghost
                    </label>
                </div>
                <div class="option-hint">
                    ğŸ’¡ <span id="intelligentCount">0</span> czÄ…stek | ğŸ–±ï¸ Prawy przycisk = dodaj
                </div>
            </div>
        </div>

        <div class="legend-item mech-bonds">
            <label>
                <input type="checkbox" id="bondsCheckbox">
                <span class="color-dot" style="color: #FFBE0B;">â—</span>
                <span class="text">ğŸ”— Molecular Bonds - tworzenie wiÄ…zaÅ„</span>
                <span class="tooltip-icon">?
                    <span class="tooltip-text">CzÄ…stki RÃ“Å»NYCH kolorÃ³w ktÃ³re sÄ… stabilne obok siebie przez okreÅ›lony czas tworzÄ… trwaÅ‚e wiÄ…zania. Identyczne kolory NIE wiÄ…Å¼Ä… siÄ™! Max Bonds: 3-5 | Bond Length: staÅ‚a dÅ‚ugoÅ›Ä‡ wiÄ…zania!</span>
                </span>
            </label>
            
            <!-- Opcje bonds (ukryte domyÅ›lnie) -->
            <div class="mech-options" id="bondsOptions" style="display: none;">
                <div class="option-row">
                    <label>Formation Time:</label>
                    <input type="range" id="bondFormationTime" min="1" max="30" value="10" step="1">
                    <span class="option-value" id="bondFormationTimeValue">10s</span>
                </div>
                <div class="option-row">
                    <label>Max Distance:</label>
                    <input type="range" id="bondMaxDistance" min="5" max="30" value="15" step="1">
                    <span class="option-value" id="bondMaxDistanceValue">15px</span>
                </div>
                <div class="option-row">
                    <label>Max Bonds:</label>
                    <input type="range" id="bondMaxBonds" min="3" max="5" value="5" step="1">
                    <span class="option-value" id="bondMaxBondsValue">5</span>
                </div>
                <div class="option-row">
                    <label>Bond Length:</label>
                    <input type="range" id="bondLength" min="5" max="30" value="10" step="1">
                    <span class="option-value" id="bondLengthValue">10px</span>
                </div>
                <div class="option-hint">
                    ğŸ”— <span id="bondsCount">0</span> aktywnych wiÄ…zaÅ„
                </div>
            </div>
        </div>


    </div>
</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startStopBtn = document.getElementById('startStopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const randomizeBtn = document.getElementById('randomizeBtn');
        
        const seedSelect = document.getElementById('seedSelect');
        const seedInput = document.getElementById('seedInput');
        const loadSeedBtn = document.getElementById('loadSeedBtn');
        const currentSeedDisplay = document.getElementById('currentSeedDisplay');
        const initModeSelect = document.getElementById('initModeSelect');
        const boundaryModeSelect = document.getElementById('boundaryModeSelect');
        
        const attractionCheckbox = document.getElementById('attractionCheckbox');
        const chargesCheckbox = document.getElementById('chargesCheckbox');
        const massCheckbox = document.getElementById('massCheckbox');
        const mixingCheckbox = document.getElementById('mixingCheckbox');
        const vortexCheckbox = document.getElementById('vortexCheckbox');
        const swarmCheckbox = document.getElementById('swarmCheckbox');
        const massTransferCheckbox = document.getElementById('massTransferCheckbox');
        const massHierarchyCheckbox = document.getElementById('massHierarchyCheckbox');
        const intelligentCheckbox = document.getElementById('intelligentCheckbox');
        const intelligentOptions = document.getElementById('intelligentOptions');
        
        const bondsCheckbox = document.getElementById('bondsCheckbox');
        const bondsOptions = document.getElementById('bondsOptions');
        const bondFormationTime = document.getElementById('bondFormationTime');
        const bondFormationTimeValue = document.getElementById('bondFormationTimeValue');
        const bondMaxDistance = document.getElementById('bondMaxDistance');
        const bondMaxDistanceValue = document.getElementById('bondMaxDistanceValue');
        const bondMaxBonds = document.getElementById('bondMaxBonds');
        const bondMaxBondsValue = document.getElementById('bondMaxBondsValue');
        const bondLength = document.getElementById('bondLength');
        const bondLengthValue = document.getElementById('bondLengthValue');
        const bondsCount = document.getElementById('bondsCount');
        
        const scannerToggle = document.getElementById('scannerToggle');
        const scannerContent = document.getElementById('scannerContent');
        // Life Scanner - RANGE SLIDERS (dual)
        const lifeMinParticlesFrom = document.getElementById('lifeMinParticlesFrom');
        const lifeMinParticlesTo = document.getElementById('lifeMinParticlesTo');
        const lifeMinParticlesValue = document.getElementById('lifeMinParticlesValue');
        
        const lifeMinColorsFrom = document.getElementById('lifeMinColorsFrom');
        const lifeMinColorsTo = document.getElementById('lifeMinColorsTo');
        const lifeMinColorsValue = document.getElementById('lifeMinColorsValue');
        
        const lifeMaxDistanceFrom = document.getElementById('lifeMaxDistanceFrom');
        const lifeMaxDistanceTo = document.getElementById('lifeMaxDistanceTo');
        const lifeMaxDistanceValue = document.getElementById('lifeMaxDistanceValue');
        
        const lifeMaxSpeedDiffFrom = document.getElementById('lifeMaxSpeedDiffFrom');
        const lifeMaxSpeedDiffTo = document.getElementById('lifeMaxSpeedDiffTo');
        const lifeMaxSpeedDiffValue = document.getElementById('lifeMaxSpeedDiffValue');
        
        const lifeFormsCount = document.getElementById('lifeFormsCount');
        
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const densityInput = document.getElementById('densityInput');
        const densityValue = document.getElementById('densityValue');
        const speciesInput = document.getElementById('speciesInput');
        const speciesValue = document.getElementById('speciesValue');
        const speedInput = document.getElementById('speedInput');
        const speedValue = document.getElementById('speedValue');
        const applySpeciesBtn = document.getElementById('applySpeciesBtn');
        
        // Intelligent Life elements
        const futureFramesInput = document.getElementById('futureFramesInput');
        const futureValue = document.getElementById('futureValue');
        const showGhostCheckbox = document.getElementById('showGhostCheckbox');
        
        // Mechanics Options elements
        const attractionOptions = document.getElementById('attractionOptions');
        const attractionStrength = document.getElementById('attractionStrength');
        const attractionStrengthValue = document.getElementById('attractionStrengthValue');
        const editMatrixBtn = document.getElementById('editMatrixBtn');
        const interactionMatrixContainer = document.getElementById('interactionMatrixContainer');
        const interactionMatrixDiv = document.getElementById('interactionMatrix');
        const viewPropertiesBtn = document.getElementById('viewPropertiesBtn');
        const colorPropertiesContainer = document.getElementById('colorPropertiesContainer');
        const colorPropertiesTable = document.getElementById('colorPropertiesTable');
        
        const chargesOptions = document.getElementById('chargesOptions');
        const chargeForce = document.getElementById('chargeForce');
        const chargeForceValue = document.getElementById('chargeForceValue');
        
        const massOptions = document.getElementById('massOptions');
        const massEffect = document.getElementById('massEffect');
        const massEffectValue = document.getElementById('massEffectValue');
        
        const mixingOptions = document.getElementById('mixingOptions');
        const blendRateInput = document.getElementById('blendRate');
        const blendRateValue = document.getElementById('blendRateValue');
        
        const vortexOptions = document.getElementById('vortexOptions');
        const vorticnessSlider = document.getElementById('vorticnessSlider');
        const vorticnessValueSpan = document.getElementById('vorticnessValue');
        
        const swarmOptions = document.getElementById('swarmOptions');
        const swarmStrengthInput = document.getElementById('swarmStrength');
        const swarmStrengthValue = document.getElementById('swarmStrengthValue');
        const swarmRangeInput = document.getElementById('swarmRange');
        const swarmRangeValue = document.getElementById('swarmRangeValue');
        
        const massTransferOptions = document.getElementById('massTransferOptions');
        const transferRateInput = document.getElementById('transferRate');
        const transferRateValue = document.getElementById('transferRateValue');
        
        const massHierarchyOptions = document.getElementById('massHierarchyOptions');
        const hierarchyStrengthInput = document.getElementById('hierarchyStrength');
        const hierarchyStrengthValue = document.getElementById('hierarchyStrengthValue');
        
        const viscosityCheckbox = document.getElementById('viscosityCheckbox');
        const viscosityOptions = document.getElementById('viscosityOptions');
        const viscosityInput = document.getElementById('viscosityInput');
        const viscosityValueSpan = document.getElementById('viscosityValueSpan');

        let WIDTH = 1000;
        let HEIGHT = 500;
        let PARTICLE_COUNT = 1000; // STAGE 4: WebWorker-ready (zwiÄ™kszone z 600!) // ZWIÄ˜KSZONE z 300 â†’ 600 (Stage 3 optimization!)
        let SPECIES_COUNT = 6;
        let SPEED_MULTIPLIER = 1.0;
        let SPEED_BEFORE_PAUSE = 1.0;
        let VISCOSITY = 0.98;
        let VORTICNESS_MULTIPLIER = 0.025;
        let CURRENT_SEED = null;
        let INIT_MODE = 'random';
        let BOUNDARY_MODE = 'warp';
        
        // Mechanics Options - Multipliers dla kaÅ¼dej mechaniki
        let ATTRACTION_STRENGTH = 1.0;  // 100%
        let CHARGE_FORCE = 1.0;         // 100%
        let MASS_EFFECT_MULTIPLIER = 1.0;  // 100%
        let BLEND_RATE = 0.02;          // 2% (was hardcoded 0.1 in mixColor)
        let SWARM_STRENGTH = 0.05;      // 50% (was hardcoded 0.05)
        let SWARM_RANGE = 100;          // 100px (was hardcoded 100)
        let TRANSFER_RATE = 0.01;       // 1% per collision
        let HIERARCHY_STRENGTH = 1.0;    // 100%
        
        // Intelligent Life - Time-Loop Particles
        let FUTURE_FRAMES = 10;  // Ile klatek do przodu przewidywaÄ‡
        let SHOW_FUTURE_GHOST = true;  // Czy pokazywaÄ‡ "ducha" z przyszÅ‚oÅ›ci
        let intelligentParticles = [];  // Lista inteligentnych czÄ…stek
        let nextIntelligentColor = 0;  // Counter dla unikalnych kolorÃ³w

        let isRunning = false;
        let animationId = null;
        let particles = [];
        let wasRunningBeforeSpeedZero = false;
        
        const SAMPLE_NAMES = {
            '42': 'The Answer',
            '144714130': 'Colorful Colonies',
            '387363571': 'Colonies and Vortex',
            '882183331': 'Swarms',
            '405382535': 'Heavy Traffic',
            '69129389': 'From Dot to Chaos',
            '143757039': 'Angry Virus',
            '377343605': 'Blue Planets',
            '889271368': 'Pink and Orange',
            '99141546': 'Fast Life',
            '204301394': 'Medusa',
            '820390980': 'Colony',
            '135308335': 'Going to Boring',
            '18731596': 'Slow But Go',
            '67276887': 'Crazy',
            '423640366': 'They Are Hungry',
            '19595201': 'Hungry But Too Slow'
        };
        
        let mousePressed = false;
        let mouseX = 0;
        let mouseY = 0;
        const MOUSE_RANGE = 100;
        const MOUSE_FORCE = 0.6;
        
        let enableAttraction = true;
        let enableCharges = false;
        let enableMass = true;
        let enableMixing = false;
        let enableVortex = false;
        let enableSwarm = false;
        let enableMassTransfer = false;
        let enableMassHierarchy = false;
        let enableViscosity = true;  // DomyÅ›lnie wÅ‚Ä…czona
        let enableBonds = false;
        
        // Life Detection system
        let enableLifeDetection = false;
        // Life Scanner - RANGES (from-to)
        let LIFE_MIN_PARTICLES_FROM = 5;
        let LIFE_MIN_PARTICLES_TO = 20;
        
        let LIFE_MIN_COLORS_FROM = 2;
        let LIFE_MIN_COLORS_TO = 6;
        
        let LIFE_MAX_DISTANCE_FROM = 20;
        let LIFE_MAX_DISTANCE_TO = 50;
        
        let LIFE_MAX_SPEED_DIFF_FROM = 1;
        let LIFE_MAX_SPEED_DIFF_TO = 5;
        
        let detectedLifeForms = []; // Array of clusters
        
        // Molecular Bonds system
        let BOND_FORMATION_TIME = 10; // seconds
        let BOND_MAX_DISTANCE = 15; // pixels (detection range)
        let MAX_BONDS_PER_PARTICLE = 5; // 3-5 bonds
        let BOND_LENGTH = 10; // pixels (enforced bond length - FIXED!)
        let bondCandidates = new Map(); // Map<"id1-id2", { frames: number, distance: number }>
        let activeBonds = []; // Array<{ p1, p2, angle1, angle2 }>
        let particleIDCounter = 0; // Global counter for unique IDs
        
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = performance.now();
        
        function torusDelta(a, b, size) {
            let d = b - a;
            if (Math.abs(d) > size / 2) {
                d -= Math.sign(d) * size;
            }
            return d;
        }

        function torusDistance(x1, y1, x2, y2) {
            const dx = torusDelta(x1, x2, WIDTH);
            const dy = torusDelta(y1, y2, HEIGHT);
            return Math.sqrt(dx * dx + dy * dy);
        }

        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            
            range(min, max) {
                return min + this.next() * (max - min);
            }
            
            int(min, max) {
                return Math.floor(this.range(min, max + 1));
            }
            
            bool() {
                return this.next() < 0.5;
            }
        }

        class SpatialGrid {
            constructor(width, height, cellSize) {
                this.width = width;
                this.height = height;
                this.cellSize = cellSize;
                this.cols = Math.ceil(width / cellSize);
                this.rows = Math.ceil(height / cellSize);
                this.grid = new Map();
            }

            clear() {
                this.grid.clear();
            }

            getCellKey(x, y) {
                const col = Math.floor(x / this.cellSize);
                const row = Math.floor(y / this.cellSize);
                return `${col},${row}`;
            }

            insert(particle) {
                if (particle.x < 0 || particle.x >= this.width || 
                    particle.y < 0 || particle.y >= this.height) {
                    return;
                }
                
                const key = this.getCellKey(particle.x, particle.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(particle);
            }

            getNearby(particle, range) {
                const nearby = [];
                const col = Math.floor(particle.x / this.cellSize);
                const row = Math.floor(particle.y / this.cellSize);
                const cellRadius = Math.ceil(range / this.cellSize);
                
                for (let i = -cellRadius; i <= cellRadius; i++) {
                    for (let j = -cellRadius; j <= cellRadius; j++) {
                        const wrappedCol = (col + i + this.cols) % this.cols;
                        const wrappedRow = (row + j + this.rows) % this.rows;
                        const key = `${wrappedCol},${wrappedRow}`;
                        
                        if (this.grid.has(key)) {
                            nearby.push(...this.grid.get(key));
                        }
                    }
                }
                
                return nearby;
            }
        }

        let spatialGrid = null;

        function updateButtonState() {
            startStopBtn.textContent = isRunning ? 'Stop' : 'Start';
            
            if (isRunning) {
                startStopBtn.classList.add('running');
            } else {
                startStopBtn.classList.remove('running');
            }
            
            console.log('ğŸ”„ updateButtonState(): isRunning =', isRunning, 'przycisk =', startStopBtn.textContent);
        }

        function generateFromSeed(seed) {
            const rng = new SeededRandom(seed);
            
            console.log(`ğŸŒ± Generated seed: ${seed}`);
            
            const mechanics = {
                attraction: rng.bool(),
                charges: rng.bool(),
                mass: rng.bool(),
                mixing: rng.bool(),
                vortex: rng.bool(),
                swarm: rng.bool(),
                massTransfer: rng.bool(),
                massHierarchy: rng.bool()
                // bonds: NOT in seed - manual only (performance)
            };
            
            const boundaryModeOptions = ['warp', 'wall', 'endless'];
            const initModeOptions = ['random', 'bigbang', 'gradient'];
            
            const settings = {
                ...mechanics,
                boundaryMode: boundaryModeOptions[Math.floor(rng.next() * 3)],
                initMode: initModeOptions[Math.floor(rng.next() * 3)],
                particleCount: rng.int(75, 3000),
                speciesCount: rng.int(1, 15),
                speed: rng.int(0, 200),
                viscosity: rng.int(90, 99),
                vorticness: Math.round(rng.range(0, 5) * 10) / 10
            };
            
            const colors = DEFAULT_COLORS.slice(0, settings.speciesCount).map((color, i) => {
                return {
                    hex: color.hex,
                    name: color.name,
                    charge: settings.charges ? (rng.bool() ? 1 : -1) : 0,
                    mass: settings.mass ? rng.range(0.5, 1.5) : 1.0,
                    interactionRange: rng.int(30, 150),
                    vorticness: settings.vortex ? rng.range(0.0, 1.0) : 0
                };
            });
            
            const colorNames = colors.map(c => c.name);
            
            const matrix = {};
            colorNames.forEach(color1 => {
                matrix[color1] = {};
                colorNames.forEach(color2 => {
                    if (settings.attraction) {
                        if (color1 === 'white' && color2 === 'white') {
                            matrix[color1][color2] = rng.range(-0.6, -0.3);
                        } else if (color1 === 'black' && color2 === 'black') {
                            matrix[color1][color2] = rng.range(0.3, 0.6);
                        } else {
                            matrix[color1][color2] = rng.range(-0.6, 0.6);
                        }
                    } else {
                        matrix[color1][color2] = 0;
                    }
                });
            });
            
            console.log('  Mechanics:', mechanics);
            console.log('  Boundary:', settings.boundaryMode, 'Init:', settings.initMode);
            console.log('  Particles:', settings.particleCount, 'Species:', settings.speciesCount);
            console.log('  Speed:', settings.speed + '%', 'Viscosity:', settings.viscosity/100);
            console.log('  Vorticness:', settings.vorticness + '%');
            
            return { settings, colors, matrix };
        }

        const DEFAULT_COLORS = [
            { hex: '#FFFFFF', charge: -1, mass: 1.05, interactionRange: 50, vorticness: 0.25, name: 'white' },
            { hex: '#000000', charge: 1, mass: 0.95, interactionRange: 50, vorticness: 0.35, name: 'black' },
            { hex: '#FF0000', charge: 1, mass: 1.0, interactionRange: 50, vorticness: 0.3, name: 'red' },
            { hex: '#00FF00', charge: -1, mass: 0.8, interactionRange: 50, vorticness: 0.2, name: 'green' },
            { hex: '#0000FF', charge: 1, mass: 1.2, interactionRange: 50, vorticness: 0.5, name: 'blue' },
            { hex: '#00FFFF', charge: -1, mass: 0.9, interactionRange: 50, vorticness: 0.1, name: 'cyan' },
            { hex: '#FF00FF', charge: 1, mass: 1.1, interactionRange: 50, vorticness: 0.4, name: 'magenta' },
            { hex: '#FFFF00', charge: -1, mass: 0.7, interactionRange: 50, vorticness: 0.6, name: 'yellow' },
            { hex: '#FFBF00', charge: 1, mass: 0.85, interactionRange: 50, vorticness: 0.45, name: 'amber' },
            { hex: '#8000FF', charge: -1, mass: 1.15, interactionRange: 50, vorticness: 0.15, name: 'purple' },
            { hex: '#FF6600', charge: 1, mass: 0.75, interactionRange: 50, vorticness: 0.55, name: 'orange' },
            { hex: '#FF69B4', charge: -1, mass: 1.25, interactionRange: 50, vorticness: 0.2, name: 'pink' },
            { hex: '#00FF88', charge: 1, mass: 0.9, interactionRange: 50, vorticness: 0.4, name: 'lime' },
            { hex: '#00CED1', charge: -1, mass: 1.1, interactionRange: 50, vorticness: 0.3, name: 'turquoise' },
            { hex: '#FF1493', charge: 1, mass: 0.8, interactionRange: 50, vorticness: 0.5, name: 'deeppink' }
        ];

        function generateDefaultInteractionMatrix(colors) {
            const matrix = {};
            const names = colors.map(c => c.name);
            
            names.forEach((name1, i) => {
                matrix[name1] = {};
                names.forEach((name2, j) => {
                    if (name1 === 'white' && name2 === 'white') {
                        matrix[name1][name2] = -0.5;
                    } else if (name1 === 'black' && name2 === 'black') {
                        matrix[name1][name2] = 0.5;
                    } else {
                        const seed = (i * 7 + j * 13) % 37;
                        const value = (seed / 37) * 1.2 - 0.6;
                        matrix[name1][name2] = Math.round(value * 10) / 10;
                    }
                });
            });
            
            return matrix;
        }

        const DEFAULT_INTERACTION_MATRIX = generateDefaultInteractionMatrix(DEFAULT_COLORS);
        let COLORS = JSON.parse(JSON.stringify(DEFAULT_COLORS));
        let INTERACTION_MATRIX = JSON.parse(JSON.stringify(DEFAULT_INTERACTION_MATRIX));

        class Particle {
            constructor(initX = null, initY = null) {
                this.id = particleIDCounter++; // Unique ID
                this.x = initX !== null ? initX : Math.random() * WIDTH;
                this.y = initY !== null ? initY : Math.random() * HEIGHT;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.colorData = COLORS[Math.floor(Math.random() * SPECIES_COUNT)];
                this.radius = 2;
                this.alpha = 1;
                this.dead = false;
                this.bonds = []; // Array of bonded particle IDs
            }

            update(particles) {
                if (SPEED_MULTIPLIER <= 0) {
                    return;
                }

                // Viscosity (lepkoÅ›Ä‡ przestrzeni) - tylko gdy wÅ‚Ä…czone
                if (enableViscosity) {
                    this.vx *= VISCOSITY;
                    this.vy *= VISCOSITY;
                }

                if (mousePressed) {
                    const dx = torusDelta(this.x, mouseX, WIDTH);
                    const dy = torusDelta(this.y, mouseY, HEIGHT);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < MOUSE_RANGE && dist > 0) {
                        const strength = (1 - dist / MOUSE_RANGE) * MOUSE_FORCE;
                        this.vx += (dx / dist) * strength;
                        this.vy += (dy / dist) * strength;
                    }
                }

                if (enableSwarm) {
                    let centerX = 0, centerY = 0, count = 0;
                    
                    const nearbyForSwarm = spatialGrid ? spatialGrid.getNearby(this, SWARM_RANGE) : particles;
                    
                    for (let i = 0; i < nearbyForSwarm.length; i++) {
                        const other = nearbyForSwarm[i];
                        if (other.colorData.name === this.colorData.name) {
                            const dx = torusDelta(this.x, other.x, WIDTH);
                            const dy = torusDelta(this.y, other.y, HEIGHT);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < SWARM_RANGE && dist > 0) {
                                centerX += other.x;
                                centerY += other.y;
                                count++;
                            }
                        }
                    }
                    
                    if (count > 0) {
                        centerX /= count;
                        centerY /= count;
                        const dx = torusDelta(this.x, centerX, WIDTH);
                        const dy = torusDelta(this.y, centerY, HEIGHT);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            this.vx += (dx / dist) * SWARM_STRENGTH;
                            this.vy += (dy / dist) * SWARM_STRENGTH;
                        }
                    }
                }

                const effectiveRange = this.colorData.interactionRange;
                const nearbyParticles = spatialGrid ? spatialGrid.getNearby(this, effectiveRange) : particles;
                
                for (let i = 0; i < nearbyParticles.length; i++) {
                    const other = nearbyParticles[i];
                    if (other === this) continue;

                    const dx = torusDelta(this.x, other.x, WIDTH);
                    const dy = torusDelta(this.y, other.y, HEIGHT);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < effectiveRange && dist > 0) {
                        if (enableAttraction) {
                            const attraction = INTERACTION_MATRIX[this.colorData.name][other.colorData.name];
                            const force = (attraction * 0.5 * ATTRACTION_STRENGTH) / dist;
                            this.vx += (dx / dist) * force;
                            this.vy += (dy / dist) * force;
                        }

                        if (enableCharges) {
                            const chargeForce = (this.colorData.charge * other.colorData.charge) * -0.3 * CHARGE_FORCE / dist;
                            this.vx += (dx / dist) * chargeForce;
                            this.vy += (dy / dist) * chargeForce;  // FIX: byÅ‚o dx, powinno byÄ‡ dy!
                        }

                        if (enableVortex && dist < 80) {
                            const colorVorticness = (this.colorData.vorticness + other.colorData.vorticness) / 2;
                            const vortexStrength = colorVorticness * VORTICNESS_MULTIPLIER * 0.3 * (1 - dist / 80);
                            this.vx += (-dy / dist) * vortexStrength;
                            this.vy += (dx / dist) * vortexStrength;
                        }

                        if (enableMixing && dist < 8) {
                            this.mixColor(other);
                        }
                        
                        if (enableMassTransfer && dist < 5) {
                            const massDiff = this.colorData.mass - other.colorData.mass;
                            const transfer = massDiff * TRANSFER_RATE;
                            
                            this.colorData.mass -= transfer;
                            other.colorData.mass += transfer;
                            
                            this.colorData.mass = Math.max(0.3, Math.min(2.0, this.colorData.mass));
                            other.colorData.mass = Math.max(0.3, Math.min(2.0, other.colorData.mass));
                        }
                    }
                }

                const massEffect = enableMass ? (2 / this.colorData.mass * MASS_EFFECT_MULTIPLIER) : 2;
                this.x += this.vx * massEffect * SPEED_MULTIPLIER;
                this.y += this.vy * massEffect * SPEED_MULTIPLIER;

                if (BOUNDARY_MODE === 'warp') {
                    this.x = (this.x + WIDTH) % WIDTH;
                    this.y = (this.y + HEIGHT) % HEIGHT;
                } 
                else if (BOUNDARY_MODE === 'wall') {
                    if (this.x < 0 || this.x > WIDTH) {
                        this.vx *= -0.8;
                        this.x = Math.max(0, Math.min(WIDTH, this.x));
                        
                        if (enableMassTransfer) {
                            this.colorData.mass *= 0.95;
                            this.colorData.mass = Math.max(0.3, this.colorData.mass);
                        }
                    }
                    if (this.y < 0 || this.y > HEIGHT) {
                        this.vy *= -0.8;
                        this.y = Math.max(0, Math.min(HEIGHT, this.y));
                        
                        if (enableMassTransfer) {
                            this.colorData.mass *= 0.95;
                            this.colorData.mass = Math.max(0.3, this.colorData.mass);
                        }
                    }
                }
                else if (BOUNDARY_MODE === 'endless') {
                    if (this.x < -50 || this.x > WIDTH + 50 || this.y < -50 || this.y > HEIGHT + 50) {
                        this.dead = true;
                    }
                }

                const maxSpeed = 3;
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }
            }

            mixColor(other) {
                if (Math.random() < 0.02) {
                    const r1 = parseInt(this.colorData.hex.slice(1, 3), 16);
                    const g1 = parseInt(this.colorData.hex.slice(3, 5), 16);
                    const b1 = parseInt(this.colorData.hex.slice(5, 7), 16);
                    
                    const r2 = parseInt(other.colorData.hex.slice(1, 3), 16);
                    const g2 = parseInt(other.colorData.hex.slice(3, 5), 16);
                    const b2 = parseInt(other.colorData.hex.slice(5, 7), 16);

                    const nr = Math.floor(r1 * (1 - BLEND_RATE) + r2 * BLEND_RATE);
                    const ng = Math.floor(g1 * (1 - BLEND_RATE) + g2 * BLEND_RATE);
                    const nb = Math.floor(b1 * (1 - BLEND_RATE) + b2 * BLEND_RATE);

                    this.colorData = {
                        ...this.colorData,
                        hex: `#${nr.toString(16).padStart(2, '0')}${ng.toString(16).padStart(2, '0')}${nb.toString(16).padStart(2, '0')}`
                    };
                }
            }

            draw(ctx) {
                const drawRadius = this.colorData.mass * 2.0;
                
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.colorData.hex;
                
                ctx.fillStyle = this.colorData.hex;
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, drawRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }

        // Intelligent Particle - Time-Loop Particle (widzi przyszÅ‚oÅ›Ä‡!)
        class IntelligentParticle extends Particle {
            constructor(x, y, colorHex) {
                super(x, y);
                
                // Unikalny kolor (nie z wygenerowanej listy)
                this.colorData = {
                    hex: colorHex,
                    charge: 0,
                    mass: 1.0,
                    interactionRange: 50,
                    vorticness: 0.3,
                    name: `intelligent_${nextIntelligentColor++}`
                };
                
                this.isIntelligent = true;
                this.futureX = this.x;
                this.futureY = this.y;
                this.radius = 3;  // Nieco wiÄ™ksza
            }
            
            // Przewiduje przyszÅ‚Ä… pozycjÄ™ symulujÄ…c N krokÃ³w do przodu
            predictFuture(frames, allParticles) {
                // Kopia obecnego stanu
                let futureX = this.x;
                let futureY = this.y;
                let futureVX = this.vx;
                let futureVY = this.vy;
                
                // Symuluj N krokÃ³w do przodu
                for (let step = 0; step < frames; step++) {
                    // Viscosity (lepkoÅ›Ä‡ przestrzeni) - tylko gdy wÅ‚Ä…czone
                    if (enableViscosity) {
                        futureVX *= VISCOSITY;
                        futureVY *= VISCOSITY;
                    }
                    
                    // Interakcje z innymi czÄ…stkami (tylko widocznymi, nie ghost)
                    // UÅ¼ywamy spatial grid - przekazujemy temporary particle object
                    const tempParticle = {x: futureX, y: futureY};
                    const neighbors = spatialGrid.getNearby(tempParticle, this.colorData.interactionRange);
                    
                    neighbors.forEach(other => {
                        if (other === this || other.isIntelligent) return;
                        
                        const dx = torusDelta(other.x, futureX, WIDTH);
                        const dy = torusDelta(other.y, futureY, HEIGHT);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < this.colorData.interactionRange && dist > 0) {
                            // Attraction (jeÅ›li wÅ‚Ä…czone)
                            if (enableAttraction) {
                                const attraction = INTERACTION_MATRIX[this.colorData.name]?.[other.colorData.name] || 0;
                                const force = (attraction * 0.5) / dist;
                                futureVX += (dx / dist) * force;
                                futureVY += (dy / dist) * force;
                            }
                        }
                    });
                    
                    // Update position
                    const massEffect = enableMass ? (2 / this.colorData.mass * MASS_EFFECT_MULTIPLIER) : 2;
                    futureX += futureVX * massEffect * SPEED_MULTIPLIER;
                    futureY += futureVY * massEffect * SPEED_MULTIPLIER;
                    
                    // Boundaries (zgodnie z BOUNDARY_MODE)
                    if (BOUNDARY_MODE === 'warp') {
                        if (futureX < 0) futureX = WIDTH;
                        if (futureX > WIDTH) futureX = 0;
                        if (futureY < 0) futureY = HEIGHT;
                        if (futureY > HEIGHT) futureY = 0;
                    } else if (BOUNDARY_MODE === 'wall') {
                        if (futureX < 0 || futureX > WIDTH) {
                            futureVX *= -0.8;
                            futureX = Math.max(0, Math.min(WIDTH, futureX));
                        }
                        if (futureY < 0 || futureY > HEIGHT) {
                            futureVY *= -0.8;
                            futureY = Math.max(0, Math.min(HEIGHT, futureY));
                        }
                    }
                    
                    // Limit velocity
                    const maxSpeed = 3;
                    const speed = Math.sqrt(futureVX * futureVX + futureVY * futureVY);
                    if (speed > maxSpeed) {
                        futureVX = (futureVX / speed) * maxSpeed;
                        futureVY = (futureVY / speed) * maxSpeed;
                    }
                }
                
                return {x: futureX, y: futureY};
            }
            
            update(particles) {
                // Najpierw normalna aktualizacja
                super.update(particles);
                
                // Potem przewiduj przyszÅ‚oÅ›Ä‡ i unikaj samego siebie!
                if (FUTURE_FRAMES > 0) {
                    const futurePos = this.predictFuture(FUTURE_FRAMES, particles);
                    this.futureX = futurePos.x;
                    this.futureY = futurePos.y;
                    
                    // Odpychanie od przyszÅ‚ej wersji siebie
                    const dx = torusDelta(this.futureX, this.x, WIDTH);
                    const dy = torusDelta(this.futureY, this.y, HEIGHT);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 30 && dist > 0) {
                        // Im bliÅ¼ej przyszÅ‚ej siebie, tym mocniejsze odpychanie
                        const avoidanceForce = (1 - dist / 30) * 0.8;
                        this.vx -= (dx / dist) * avoidanceForce;
                        this.vy -= (dy / dist) * avoidanceForce;
                    }
                }
            }
            
            draw(ctx) {
                // Najpierw rysuj ghost (jeÅ›li wÅ‚Ä…czony)
                if (SHOW_FUTURE_GHOST && FUTURE_FRAMES > 0) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.colorData.hex;
                    ctx.fillStyle = this.colorData.hex;
                    ctx.globalAlpha = 0.3;  // Przezroczysty duch
                    ctx.beginPath();
                    ctx.arc(this.futureX, this.futureY, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Linia Å‚Ä…czÄ…ca teraÅºniejszoÅ›Ä‡ z przyszÅ‚oÅ›ciÄ…
                    ctx.strokeStyle = this.colorData.hex;
                    ctx.globalAlpha = 0.2;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.futureX, this.futureY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Potem rysuj obecnÄ… czÄ…stkÄ™ (jaÅ›niejsza, wiÄ™ksza)
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.colorData.hex;
                ctx.fillStyle = this.colorData.hex;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ring around (oznaczenie inteligentnej)
                ctx.strokeStyle = this.colorData.hex;
                ctx.globalAlpha = 0.6;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }

        // MOLECULAR BONDS FUNCTIONS
        function detectAndCreateBonds(particles) {
            if (!enableBonds) return;
            
            const targetFPS = 60;
            const requiredFrames = BOND_FORMATION_TIME * targetFPS;
            
            // Check all particle pairs
            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                if (p1.bonds.length >= MAX_BONDS_PER_PARTICLE) continue; // Max bonds (3-5)
                
                for (let j = i + 1; j < particles.length; j++) {
                    const p2 = particles[j];
                    if (p2.bonds.length >= MAX_BONDS_PER_PARTICLE) continue;
                    
                    // Same color cannot bond (only different colors!)
                    if (p1.colorData.name === p2.colorData.name) continue;
                    
                    // Already bonded?
                    if (p1.bonds.includes(p2.id)) continue;
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < BOND_MAX_DISTANCE) {
                        const pairKey = p1.id < p2.id ? `${p1.id}-${p2.id}` : `${p2.id}-${p1.id}`;
                        
                        if (!bondCandidates.has(pairKey)) {
                            bondCandidates.set(pairKey, { frames: 0, distance: dist });
                        }
                        
                        const candidate = bondCandidates.get(pairKey);
                        
                        // Check if distance is stable (not changing much)
                        const distChange = Math.abs(dist - candidate.distance);
                        if (distChange < 1.0) { // Stable (less than 1px change)
                            candidate.frames++;
                            candidate.distance = dist;
                            
                            // Form bond!
                            if (candidate.frames >= requiredFrames) {
                                const angle1 = Math.atan2(dy, dx);
                                const angle2 = Math.atan2(-dy, -dx);
                                
                                // Check if this angle slot is available (5 slots, every 72Â°)
                                if (canFormBondAtAngle(p1, angle1) && canFormBondAtAngle(p2, angle2)) {
                                    p1.bonds.push(p2.id);
                                    p2.bonds.push(p1.id);
                                    activeBonds.push({ p1: p1.id, p2: p2.id, distance: dist });
                                    bondCandidates.delete(pairKey);
                                    console.log(`ğŸ”— Bond formed: ${p1.id} â†” ${p2.id} at ${dist.toFixed(1)}px`);
                                }
                            }
                        } else {
                            // Not stable, reset
                            candidate.frames = 0;
                            candidate.distance = dist;
                        }
                    } else {
                        // Too far, remove candidate
                        const pairKey = p1.id < p2.id ? `${p1.id}-${p2.id}` : `${p2.id}-${p1.id}`;
                        bondCandidates.delete(pairKey);
                    }
                }
            }
        }
        
        function canFormBondAtAngle(particle, angle) {
            // Normalize angle to 0-2Ï€
            angle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            
            const slotSize = (2 * Math.PI) / MAX_BONDS_PER_PARTICLE;
            const slotIndex = Math.floor(angle / slotSize);
            
            // Initialize bondSlots dynamically based on MAX_BONDS_PER_PARTICLE
            if (!particle.bondSlots) {
                particle.bondSlots = new Array(MAX_BONDS_PER_PARTICLE).fill(false);
            }
            
            if (slotIndex < MAX_BONDS_PER_PARTICLE && !particle.bondSlots[slotIndex]) {
                particle.bondSlots[slotIndex] = true;
                return true;
            }
            return false;
        }
        
        function applyBondConstraints(particles) {
            if (!enableBonds || activeBonds.length === 0) return;
            
            // Create particle lookup map
            const particleMap = new Map();
            particles.forEach(p => particleMap.set(p.id, p));
            
            // Apply bond constraints (keep bonded particles at fixed distance)
            activeBonds.forEach(bond => {
                const p1 = particleMap.get(bond.p1);
                const p2 = particleMap.get(bond.p2);
                
                if (!p1 || !p2) return;
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const currentDist = Math.sqrt(dx * dx + dy * dy);
                
                if (currentDist === 0) return;
                
                // Calculate correction - ENFORCE FIXED BOND_LENGTH!
                const diff = currentDist - BOND_LENGTH;
                const correctionFactor = diff / currentDist * 0.5; // 50% correction each
                
                // Apply correction
                const cx = dx * correctionFactor;
                const cy = dy * correctionFactor;
                
                p1.x += cx;
                p1.y += cy;
                p2.x -= cx;
                p2.y -= cy;
            });
        }
        
        // LIFE DETECTION SYSTEM
        function detectLifeForms(particles) {
            if (!enableLifeDetection) {
                detectedLifeForms = [];
                return;
            }
            
            const clusters = [];
            const visited = new Set();
            
            // Simple clustering algorithm
            particles.forEach((particle, i) => {
                if (visited.has(i)) return;
                
                const cluster = [];
                const queue = [i];
                visited.add(i);
                
                while (queue.length > 0) {
                    const currentIdx = queue.shift();
                    const current = particles[currentIdx];
                    cluster.push(current);
                    
                    // Find neighbors
                    particles.forEach((neighbor, j) => {
                        if (visited.has(j)) return;
                        
                        const dx = neighbor.x - current.x;
                        const dy = neighbor.y - current.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // CHECK DISTANCE RANGE (from-to)
                        if (dist >= LIFE_MAX_DISTANCE_FROM && dist <= LIFE_MAX_DISTANCE_TO) {
                            // Check if moving together (similar velocity)
                            const dvx = Math.abs(neighbor.vx - current.vx);
                            const dvy = Math.abs(neighbor.vy - current.vy);
                            const speedDiff = Math.sqrt(dvx * dvx + dvy * dvy);
                            
                            // CHECK VELOCITY DIFF RANGE (from-to)
                            if (speedDiff >= LIFE_MAX_SPEED_DIFF_FROM && speedDiff <= LIFE_MAX_SPEED_DIFF_TO) {
                                visited.add(j);
                                queue.push(j);
                            }
                        }
                    });
                }
                
                // CHECK PARTICLES RANGE (from-to) AND COLORS RANGE (from-to)
                if (cluster.length >= LIFE_MIN_PARTICLES_FROM && cluster.length <= LIFE_MIN_PARTICLES_TO) {
                    // Count unique colors in cluster
                    const uniqueColors = new Set(cluster.map(p => p.colorData.name));
                    
                    if (uniqueColors.size >= LIFE_MIN_COLORS_FROM && uniqueColors.size <= LIFE_MIN_COLORS_TO) {
                        clusters.push(cluster);
                    }
                }
            });
            
            detectedLifeForms = clusters;
            
            // Debug log (only when changes)
            if (Math.random() < 0.01) { // 1% chance to log (co ~100 frames)
                console.log(`ğŸ§¬ Detected ${clusters.length} life forms (${clusters.map(c => c.length).join(', ')} particles, ${clusters.map(c => new Set(c.map(p => p.colorData.name)).size).join(', ')} colors)`);
            }
        }
        
        function drawLifeForms(ctx) {
            if (!enableLifeDetection || detectedLifeForms.length === 0) return;
            
            ctx.strokeStyle = '#00FF88';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.8;
            ctx.setLineDash([5, 5]); // Dashed line
            
            detectedLifeForms.forEach((cluster, index) => {
                // Calculate bounding box
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                let avgVx = 0, avgVy = 0;
                
                cluster.forEach(p => {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                    avgVx += p.vx;
                    avgVy += p.vy;
                });
                
                avgVx /= cluster.length;
                avgVy /= cluster.length;
                const avgSpeed = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
                
                // Add padding to box
                const padding = 10;
                minX -= padding;
                minY -= padding;
                maxX += padding;
                maxY += padding;
                
                // Draw rectangle
                ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                
                // Draw label
                ctx.fillStyle = '#00FF88';
                ctx.font = '10px Orbitron';
                ctx.fillText(`Life #${index + 1} | ${cluster.length} particles | ${avgSpeed.toFixed(1)} speed`, 
                            minX, minY - 5);
            });
            
            ctx.globalAlpha = 1;
            ctx.setLineDash([]); // Reset
        }
        
        function drawBonds(ctx, particles) {
            if (!enableBonds || activeBonds.length === 0) return;
            
            const particleMap = new Map();
            particles.forEach(p => particleMap.set(p.id, p));
            
            ctx.lineWidth = 2.5; // Grubsze (byÅ‚o 1px)
            ctx.globalAlpha = 0.6; // TrochÄ™ bardziej widoczne
            
            activeBonds.forEach(bond => {
                const p1 = particleMap.get(bond.p1);
                const p2 = particleMap.get(bond.p2);
                
                if (!p1 || !p2) return;
                
                // GRADIENT od koloru p1 do koloru p2! ğŸŒˆ
                const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                gradient.addColorStop(0, p1.colorData.hex);   // Start = kolor p1
                gradient.addColorStop(1, p2.colorData.hex);   // End = kolor p2
                ctx.strokeStyle = gradient;
                
                // Glow effect (Å›rednia obu kolorÃ³w)
                ctx.shadowBlur = 8;
                // UÅ¼ywamy koloru p1 dla glow (moÅ¼na teÅ¼ zrobiÄ‡ blend, ale to prostsze)
                ctx.shadowColor = p1.colorData.hex;
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });
            
            // Reset
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function initParticles() {
            particles = [];
            
            // Reset molecular bonds
            particleIDCounter = 0;
            bondCandidates.clear();
            activeBonds = [];
            
            if (INIT_MODE === 'random') {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    particles.push(new Particle());
                }
            } 
            else if (INIT_MODE === 'bigbang') {
                const centerX = WIDTH / 2;
                const centerY = HEIGHT / 2;
                const spreadRadius = 5;
                
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const offsetX = (Math.random() - 0.5) * spreadRadius * 2;
                    const offsetY = (Math.random() - 0.5) * spreadRadius * 2;
                    particles.push(new Particle(centerX + offsetX, centerY + offsetY));
                }
            }
            else if (INIT_MODE === 'gradient') {
                const sortedColors = [...COLORS.slice(0, SPECIES_COUNT)].sort((a, b) => b.mass - a.mass);
                const particlesPerColor = Math.floor(PARTICLE_COUNT / SPECIES_COUNT);
                const remainder = PARTICLE_COUNT % SPECIES_COUNT;
                const stripWidth = WIDTH / SPECIES_COUNT;
                
                let particleIndex = 0;
                for (let colorIndex = 0; colorIndex < SPECIES_COUNT; colorIndex++) {
                    const color = sortedColors[colorIndex];
                    const count = particlesPerColor + (colorIndex < remainder ? 1 : 0);
                    const xStart = colorIndex * stripWidth;
                    const xEnd = (colorIndex + 1) * stripWidth;
                    
                    for (let i = 0; i < count; i++) {
                        const x = xStart + Math.random() * (xEnd - xStart);
                        const y = Math.random() * HEIGHT;
                        const particle = new Particle(x, y);
                        particle.colorData = color;
                        particles.push(particle);
                    }
                }
            }
            
            // Reset intelligent particles i aktualizuj licznik
            intelligentParticles = [];
            nextIntelligentColor = 0;
            document.getElementById('intelligentCount').textContent = '0';
            
            const maxRange = 150;
            spatialGrid = new SpatialGrid(WIDTH, HEIGHT, maxRange);
        }

        function drawStatusAndFPS() {
            // PÃ³Å‚przezroczyste tÅ‚o dla kontrolek statusu
            const statusWidth = 300;
            const statusHeight = 60;
            ctx.fillStyle = 'rgba(10, 10, 20, 0)'; // PÃ³Å‚przezroczyste czarne tÅ‚o
            ctx.fillRect(0, 0, statusWidth, statusHeight);
            
            let dotColor, statusLabel;
            
            if (!isRunning) {
                // Czerwone - symulacja wyÅ‚Ä…czona
                dotColor = '#FF006E';
                statusLabel = 'Symulacja wyÅ‚Ä…czona';
            } else if (SPEED_MULTIPLIER <= 0) {
                // Å»Ã³Å‚te - symulacja wstrzymana (isRunning = true, ale speed = 0)
                dotColor = '#FFBE0B';
                statusLabel = 'Symulacja wstrzymana';
            } else {
                // Zielone - symulacja dziaÅ‚a
                dotColor = '#00FF00';
                statusLabel = 'Symulacja uruchomiona';
            }
            
            ctx.fillStyle = dotColor;
            ctx.font = 'bold 20px Orbitron, Arial, sans-serif';
            ctx.shadowBlur = 5;
            ctx.shadowColor = dotColor;
            ctx.fillText('â—', 10, 20);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#00F5FF';
            ctx.font = 'bold 14px Orbitron, Arial, sans-serif';
            ctx.shadowBlur = 2.5;
            ctx.shadowColor = '#00F5FF';
            ctx.fillText(statusLabel, 32, 20);
            ctx.shadowBlur = 0;

            let fpsColor;
            if (fps <= 16) {
                fpsColor = '#FF006E';
            } else if (fps <= 23) {
                fpsColor = '#FFBE0B';
            } else {
                fpsColor = '#00FF00';
            }
            
            ctx.fillStyle = fpsColor;
            ctx.font = 'bold 20px Orbitron, Arial, sans-serif';
            ctx.shadowBlur = 5;
            ctx.shadowColor = fpsColor;
            ctx.fillText('â—', 10, 42);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#00F5FF';
            ctx.font = 'bold 14px Orbitron, Arial, sans-serif';
            ctx.shadowBlur = 2.5;
            ctx.shadowColor = '#00F5FF';
            
            let statusText = `FPS: ${fps} | CzÄ…stki: ${PARTICLE_COUNT}`;
            
            ctx.fillText(statusText, 32, 42);
            ctx.shadowBlur = 0;
        }

        function animate() {
            frameCount++;
            const now = performance.now();
            if (now - lastFpsUpdate >= 1000) {
                fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = now;
            }
            
            // ZAWSZE czyÅ›Ä‡ canvas (nawet jeÅ›li symulacja zatrzymana)
            ctx.fillStyle = 'rgba(10, 10, 20, 0.15)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Tylko jeÅ›li symulacja jest uruchomiona ORAZ szybkoÅ›Ä‡ > 0
            if (isRunning && SPEED_MULTIPLIER > 0) {
                if (spatialGrid) {
                    spatialGrid.clear();
                    for (let i = 0; i < particles.length; i++) {
                        spatialGrid.insert(particles[i]);
                    }
                }

                particles.forEach(particle => {
                    particle.update(particles);
                });
                
                // Molecular Bonds - detect and create
                detectAndCreateBonds(particles);
                
                // Molecular Bonds - apply constraints
                applyBondConstraints(particles);
                
                // Life Detection - detect clusters
                detectLifeForms(particles);

                const sortedForDrawing = [...particles].sort((a, b) => {
                    if (a.colorData.name === 'white') return -1;
                    if (b.colorData.name === 'white') return 1;
                    if (a.colorData.name === 'black') return -1;
                    if (b.colorData.name === 'black') return 1;
                    return 0;
                });
                
                // Draw bonds BEFORE particles (tak aby czÄ…stki byÅ‚y na wierzchu)
                drawBonds(ctx, sortedForDrawing);

                sortedForDrawing.forEach(particle => {
                    particle.draw(ctx);
                });
                
                // Draw life forms AFTER particles (na wierzchu)
                drawLifeForms(ctx);
                
                if (BOUNDARY_MODE === 'endless') {
                    const beforeCount = particles.length;
                    particles = particles.filter(p => !p.dead);
                    const afterCount = particles.length;
                    if (beforeCount !== afterCount) {
                        PARTICLE_COUNT = afterCount;
                    }
                }

                if (enableMassHierarchy && SPECIES_COUNT >= 2) {
                    const otherMasses = [];
                    const blackParticles = [];
                    const whiteParticles = [];
                    
                    particles.forEach(particle => {
                        if (particle.colorData.name === 'black') {
                            blackParticles.push(particle);
                        } else if (particle.colorData.name === 'white') {
                            whiteParticles.push(particle);
                        } else {
                            otherMasses.push(particle.colorData.mass);
                        }
                    });
                    
                    if (otherMasses.length > 0) {
                        const maxOtherMass = Math.max(...otherMasses);
                        const minOtherMass = Math.min(...otherMasses);
                        
                        const blackMass = Math.min(2.0, maxOtherMass + 0.1);
                        blackParticles.forEach(p => {
                            p.colorData.mass = blackMass;
                        });
                        
                        const whiteMass = Math.max(0.3, minOtherMass - 0.1);
                        whiteParticles.forEach(p => {
                            p.colorData.mass = whiteMass;
                        });
                    }
                }
            } else if (isRunning && SPEED_MULTIPLIER === 0) {
                // Symulacja jest "wstrzymana" - pokaÅ¼ czÄ…stki w miejscu
                const sortedForDrawing = [...particles].sort((a, b) => {
                    if (a.colorData.name === 'white') return -1;
                    if (b.colorData.name === 'white') return 1;
                    if (a.colorData.name === 'black') return -1;
                    if (b.colorData.name === 'black') return 1;
                    return 0;
                });

                sortedForDrawing.forEach(particle => {
                    particle.draw(ctx);
                });
            }

            // ZAWSZE rysuj wskaÅºnik statusu (nawet jeÅ›li symulacja zatrzymana)
            drawStatusAndFPS();

            if (mousePressed) {
                ctx.strokeStyle = 'rgba(0, 245, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, MOUSE_RANGE, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(0, 245, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Update bonds count display
            if (bondsCount) {
                bondsCount.textContent = activeBonds.length.toString();
            }
            
            // Update life forms count display
            if (lifeFormsCount) {
                lifeFormsCount.textContent = detectedLifeForms.length.toString();
            }

            // Kontynuuj animacjÄ™ jeÅ›li symulacja jest uruchomiona LUB jest wstrzymana (szybkoÅ›Ä‡ 0%)
            if (isRunning) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function handleStartStop() {
            console.log('ğŸ”§ DEBUG handleStartStop - BEFORE: isRunning =', isRunning, 'SPEED =', SPEED_MULTIPLIER);
            
            if (!isRunning) {
                // Start: jeÅ›li byÅ‚a wstrzymana, przywrÃ³Ä‡ prÄ™dkoÅ›Ä‡, w przeciwnym razie ustaw domyÅ›lnÄ…
                isRunning = true;
                if (SPEED_MULTIPLIER === 0 && SPEED_BEFORE_PAUSE > 0) {
                    SPEED_MULTIPLIER = SPEED_BEFORE_PAUSE;
                    speedInput.value = Math.round(SPEED_MULTIPLIER * 100);
                    speedValue.textContent = Math.round(SPEED_MULTIPLIER * 100) + '%';
                } else if (SPEED_MULTIPLIER === 0) {
                    // JeÅ›li prÄ™dkoÅ›Ä‡ byÅ‚a 0 i nie byÅ‚o zapamiÄ™tanej, ustaw domyÅ›lnÄ…
                    SPEED_MULTIPLIER = 1.0;
                    speedInput.value = 100;
                    speedValue.textContent = '100%';
                }
                animate();
            } else {
                // Stop: zatrzymaj caÅ‚kowicie
                SPEED_BEFORE_PAUSE = SPEED_MULTIPLIER;
                SPEED_MULTIPLIER = 0;
                speedInput.value = 0;
                speedValue.textContent = '0%';
                isRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                // RÄ™cznie odÅ›wieÅ¼ kontrolkÄ™ po zatrzymaniu
                drawStatusAndFPS();
            }
            
            updateButtonState();
            console.log('ğŸ”§ DEBUG handleStartStop - AFTER: isRunning =', isRunning, 'SPEED =', SPEED_MULTIPLIER);
        }

        function handleReset() {
            const wasRunning = isRunning;
            const currentSpeed = SPEED_MULTIPLIER;
            
            initParticles();
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            isRunning = wasRunning;
            SPEED_MULTIPLIER = currentSpeed;
            
            if (wasRunning) {
                animate();
            }
            
            updateButtonState();
            // Zawsze odÅ›wieÅ¼ kontrolkÄ™ po resecie
            drawStatusAndFPS();
        }

        function handleSpeedChange(speedPercent) {
            const oldSpeed = SPEED_MULTIPLIER;
            SPEED_MULTIPLIER = speedPercent / 100;
            speedValue.textContent = speedPercent + '%';
            
            // ZapamiÄ™taj poprzedniÄ… prÄ™dkoÅ›Ä‡ jeÅ›li zmieniamy z >0 na 0
            if (oldSpeed > 0 && speedPercent === 0) {
                SPEED_BEFORE_PAUSE = oldSpeed;
            }
            
            // JeÅ›li zmieniamy prÄ™dkoÅ›Ä‡ i symulacja dziaÅ‚a, odÅ›wieÅ¼ kontrolkÄ™
            if (isRunning) {
                drawStatusAndFPS();
            }
        }

        function randomizeSettings() {
            const wasRunning = isRunning;
            const currentSpeed = SPEED_MULTIPLIER;
            const useDefaults = Math.random() < 0.15;

            if (useDefaults) {
                COLORS = JSON.parse(JSON.stringify(DEFAULT_COLORS));
                INTERACTION_MATRIX = JSON.parse(JSON.stringify(DEFAULT_INTERACTION_MATRIX));
                CURRENT_SEED = null;
                currentSeedDisplay.textContent = 'DomyÅ›lne';
                
                attractionCheckbox.checked = true;
                chargesCheckbox.checked = false;
                massCheckbox.checked = true;
                mixingCheckbox.checked = false;
                vortexCheckbox.checked = false;
                swarmCheckbox.checked = false;
                massTransferCheckbox.checked = false;
                massHierarchyCheckbox.checked = false;
                enableAttraction = true;
                enableCharges = false;
                enableMass = true;
                enableMixing = false;
                enableVortex = false;
                enableSwarm = false;
                enableMassTransfer = false;
                enableMassHierarchy = false;
                
                PARTICLE_COUNT = 300;
                densityInput.value = 300;
                densityValue.textContent = '300';
                SPECIES_COUNT = 6;
                speciesInput.value = 6;
                speciesValue.textContent = '6';
                SPEED_MULTIPLIER = 1.0;
                speedInput.value = 100;
                speedValue.textContent = '100%';
                VISCOSITY = 0.98;
                
                wasRunningBeforeSpeedZero = false;
                boundaryModeSelect.value = 'warp';
                BOUNDARY_MODE = 'warp';
                initModeSelect.value = 'random';
                INIT_MODE = 'random';
            } else {
                const newSeed = Math.floor(Math.random() * 1000000000);
                loadSeedWithValue(newSeed);
            }

            initParticles();
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            isRunning = wasRunning;
            SPEED_MULTIPLIER = currentSpeed;
            
            if (wasRunning) {
                animate();
            }
            
            updateButtonState();
            
            if (!wasRunning) {
                drawStatusAndFPS();
            }
        }

        function loadSeedWithValue(seedValue) {
            const seed = parseInt(seedValue);
            if (isNaN(seed)) {
                alert('PrÃ³bka musi byÄ‡ liczbÄ… caÅ‚kowitÄ…');
                return false;
            }
            
            CURRENT_SEED = seed;
            const sampleName = SAMPLE_NAMES[seed.toString()];
            currentSeedDisplay.textContent = sampleName ? `${sampleName} (${seed})` : seed;
            
            const { settings, colors, matrix } = generateFromSeed(seed);
            
            // Checkboxy mechanik
            attractionCheckbox.checked = settings.attraction;
            chargesCheckbox.checked = settings.charges;
            massCheckbox.checked = settings.mass;
            mixingCheckbox.checked = settings.mixing;
            vortexCheckbox.checked = settings.vortex;
            swarmCheckbox.checked = settings.swarm;
            massTransferCheckbox.checked = settings.massTransfer;
            massHierarchyCheckbox.checked = settings.massHierarchy;
            bondsCheckbox.checked = false; // ALWAYS false - manual only (performance)
            enableAttraction = settings.attraction;
            enableCharges = settings.charges;
            enableMass = settings.mass;
            enableMixing = settings.mixing;
            enableVortex = settings.vortex;
            enableSwarm = settings.swarm;
            enableMassTransfer = settings.massTransfer;
            enableMassHierarchy = settings.massHierarchy;
            enableBonds = false; // ALWAYS false - manual only (performance)
            
            // PokaÅ¼/ukryj opcje mechanik
            attractionOptions.style.display = settings.attraction ? 'block' : 'none';
            chargesOptions.style.display = settings.charges ? 'block' : 'none';
            massOptions.style.display = settings.mass ? 'block' : 'none';
            mixingOptions.style.display = settings.mixing ? 'block' : 'none';
            vortexOptions.style.display = settings.vortex ? 'block' : 'none';
            swarmOptions.style.display = settings.swarm ? 'block' : 'none';
            massTransferOptions.style.display = settings.massTransfer ? 'block' : 'none';
            massHierarchyOptions.style.display = settings.massHierarchy ? 'block' : 'none';
            bondsOptions.style.display = settings.bonds ? 'block' : 'none';
            
            boundaryModeSelect.value = settings.boundaryMode;
            BOUNDARY_MODE = settings.boundaryMode;
            initModeSelect.value = settings.initMode;
            INIT_MODE = settings.initMode;
            
            PARTICLE_COUNT = settings.particleCount;
            densityInput.value = settings.particleCount;
            densityValue.textContent = settings.particleCount;
            
            SPECIES_COUNT = settings.speciesCount;
            speciesInput.value = settings.speciesCount;
            speciesValue.textContent = settings.speciesCount;
            
            handleSpeedChange(settings.speed);
            
            // VISCOSITY - update UI!
            VISCOSITY = settings.viscosity / 100;
            viscosityInput.value = settings.viscosity;
            viscosityValueSpan.textContent = (settings.viscosity / 100).toFixed(2);
            
            // VORTICNESS - update UI! (settings.vorticness to 0.0-5.0, slider to 0-100)
            const vorticnessPercent = Math.round((settings.vorticness / 5.0) * 100);
            VORTICNESS_MULTIPLIER = settings.vorticness / 100;
            vorticnessSlider.value = vorticnessPercent;
            vorticnessValue.textContent = vorticnessPercent + '%';
            
            COLORS = [...colors];
            while (COLORS.length < 15) {
                const defaultIndex = COLORS.length;
                COLORS.push(JSON.parse(JSON.stringify(DEFAULT_COLORS[defaultIndex])));
            }
            INTERACTION_MATRIX = matrix;
            
            // OdÅ›wieÅ¼ matrix UI jeÅ›li jest otwarta
            if (interactionMatrixContainer && interactionMatrixContainer.style.display !== 'none') {
                generateInteractionMatrixUI();
            }
            
            // OdÅ›wieÅ¼ color properties table jeÅ›li jest otwarta
            if (colorPropertiesContainer && colorPropertiesContainer.style.display !== 'none') {
                generateColorPropertiesTable();
            }
            
            console.log('ğŸ² Seed loaded:', {
                seed,
                mechanics: settings,
                viscosity: VISCOSITY,
                vorticness: VORTICNESS_MULTIPLIER,
                colors: COLORS.length,
                particleCount: PARTICLE_COUNT
            });
            
            return true;
        }

        function loadSeed() {
            const seedValue = seedInput.value.trim();
            if (!seedValue) {
                alert('ProszÄ™ wpisaÄ‡ numer prÃ³bki');
                return;
            }
            
            if (!loadSeedWithValue(seedValue)) {
                return;
            }
            
            const wasRunning = isRunning;
            if (isRunning) {
                isRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
            
            initParticles();
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            updateButtonState();
            
            if (wasRunning) {
                isRunning = true;
                animate();
            } else {
                drawStatusAndFPS();
            }
            
            seedInput.value = '';
            seedInput.style.display = 'none';
            loadSeedBtn.style.display = 'none';
            seedSelect.value = '';
        }

        function applySize() {
            const newWidth = parseInt(widthInput.value);
            const newHeight = parseInt(heightInput.value);
            
            if (newWidth < 200 || newWidth > 5000 || newHeight < 150 || newHeight > 5000) {
                alert('SzerokoÅ›Ä‡: 200-5000, WysokoÅ›Ä‡: 150-5000');
                return;
            }
            
            const wasRunning = isRunning;
            if (isRunning) {
                isRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
            
            WIDTH = newWidth;
            HEIGHT = newHeight;
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            
            initParticles();
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            updateButtonState();
            
            if (wasRunning) {
                isRunning = true;
                animate();
            } else {
                drawStatusAndFPS();
            }
        }

        startStopBtn.addEventListener('click', handleStartStop);
        resetBtn.addEventListener('click', handleReset);
        randomizeBtn.addEventListener('click', randomizeSettings);
        loadSeedBtn.addEventListener('click', loadSeed);
        applySpeciesBtn.addEventListener('click', handleReset);

        seedSelect.addEventListener('change', (e) => {
            const value = e.target.value;
            if (value === 'custom') {
                seedInput.style.display = 'inline-block';
                loadSeedBtn.style.display = 'inline-block';
                seedInput.focus();
            } else if (value !== '') {
                seedInput.style.display = 'none';
                loadSeedBtn.style.display = 'none';
                loadSeedWithValue(value);
                
                const wasRunning = isRunning;
                if (isRunning) {
                    isRunning = false;
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                }
                
                initParticles();
                ctx.fillStyle = '#0a0a14';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                
                updateButtonState();
                
                if (wasRunning) {
                    isRunning = true;
                    animate();
                } else {
                    drawStatusAndFPS();
                }
            } else {
                seedInput.style.display = 'none';
                loadSeedBtn.style.display = 'none';
            }
        });
        
        seedInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loadSeed();
        });
        
        initModeSelect.addEventListener('change', (e) => {
            INIT_MODE = e.target.value;
        });
        
        boundaryModeSelect.addEventListener('change', (e) => {
            BOUNDARY_MODE = e.target.value;
        });
        
        densityInput.addEventListener('input', (e) => {
            densityValue.textContent = e.target.value;
            PARTICLE_COUNT = parseInt(e.target.value);
        });
        
        speciesInput.addEventListener('input', (e) => {
            speciesValue.textContent = e.target.value;
            SPECIES_COUNT = parseInt(e.target.value);
        });
        
        speedInput.addEventListener('input', (e) => {
            const speedPercent = parseInt(e.target.value);
            handleSpeedChange(speedPercent);
        });
        
        widthInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') applySize();
        });
        heightInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') applySize();
        });
        
        attractionCheckbox.addEventListener('change', (e) => {
            enableAttraction = e.target.checked;
            attractionOptions.style.display = e.target.checked ? 'block' : 'none';
        });
        
        attractionStrength.addEventListener('input', (e) => {
            ATTRACTION_STRENGTH = parseInt(e.target.value) / 100;
            attractionStrengthValue.textContent = e.target.value + '%';
        });
        
        chargesCheckbox.addEventListener('change', (e) => {
            enableCharges = e.target.checked;
            chargesOptions.style.display = e.target.checked ? 'block' : 'none';
        });
        
        chargeForce.addEventListener('input', (e) => {
            CHARGE_FORCE = parseInt(e.target.value) / 100;
            chargeForceValue.textContent = e.target.value + '%';
        });
        
        massCheckbox.addEventListener('change', (e) => {
            enableMass = e.target.checked;
            massOptions.style.display = e.target.checked ? 'block' : 'none';
        });
        
        massEffect.addEventListener('input', (e) => {
            MASS_EFFECT_MULTIPLIER = parseInt(e.target.value) / 100;
            massEffectValue.textContent = e.target.value + '%';
        });
        
        mixingCheckbox.addEventListener('change', (e) => {
            enableMixing = e.target.checked;
            mixingOptions.style.display = e.target.checked ? 'block' : 'none';
        });
        
        blendRateInput.addEventListener('input', (e) => {
            BLEND_RATE = parseInt(e.target.value) / 1000;  // 0-100 -> 0.00-0.10
            blendRateValue.textContent = e.target.value + '%';
        });
        
        vortexCheckbox.addEventListener('change', (e) => {
            enableVortex = e.target.checked;
            vortexOptions.style.display = e.target.checked ? 'block' : 'none';
        });
        
        vorticnessSlider.addEventListener('input', (e) => {
            VORTICNESS_MULTIPLIER = parseInt(e.target.value) / 2000;  // 0-100 -> 0.00-0.05
            vorticnessValueSpan.textContent = e.target.value + '%';
        });
        
        swarmCheckbox.addEventListener('change', (e) => {
            enableSwarm = e.target.checked;
            swarmOptions.style.display = e.target.checked ? 'block' : 'none';
        });
        
        swarmStrengthInput.addEventListener('input', (e) => {
            SWARM_STRENGTH = parseInt(e.target.value) / 1000;  // 0-100 -> 0.00-0.10
            swarmStrengthValue.textContent = e.target.value + '%';
        });
        
        swarmRangeInput.addEventListener('input', (e) => {
            SWARM_RANGE = parseInt(e.target.value);
            swarmRangeValue.textContent = e.target.value + 'px';
        });
        
        massTransferCheckbox.addEventListener('change', (e) => {
            enableMassTransfer = e.target.checked;
            massTransferOptions.style.display = e.target.checked ? 'block' : 'none';
        });
        
        transferRateInput.addEventListener('input', (e) => {
            TRANSFER_RATE = parseInt(e.target.value) / 10000;  // 0-100 -> 0.000-0.010
            transferRateValue.textContent = e.target.value + '%';
        });
        
        massHierarchyCheckbox.addEventListener('change', (e) => {
            enableMassHierarchy = e.target.checked;
            massHierarchyOptions.style.display = e.target.checked ? 'block' : 'none';
        });
        
        hierarchyStrengthInput.addEventListener('input', (e) => {
            HIERARCHY_STRENGTH = parseInt(e.target.value) / 100;
            hierarchyStrengthValue.textContent = e.target.value + '%';
        });
        
        // Viscosity checkbox - toggle opcji
        viscosityCheckbox.addEventListener('change', (e) => {
            enableViscosity = e.target.checked;
            viscosityOptions.style.display = e.target.checked ? 'block' : 'none';
        });
        
        viscosityInput.addEventListener('input', (e) => {
            VISCOSITY = parseInt(e.target.value) / 100;  // 90-99 -> 0.90-0.99
            viscosityValueSpan.textContent = (parseInt(e.target.value) / 100).toFixed(2);
        });
        
        // Intelligent Life checkbox - toggle opcji
        intelligentCheckbox.addEventListener('change', (e) => {
            const isEnabled = e.target.checked;
            intelligentOptions.style.display = isEnabled ? 'block' : 'none';
            
            // JeÅ›li wyÅ‚Ä…czamy, usuÅ„ wszystkie inteligentne czÄ…stki
            if (!isEnabled) {
                particles = particles.filter(p => !p.isIntelligent);
                intelligentParticles = [];
                nextIntelligentColor = 0;
                document.getElementById('intelligentCount').textContent = '0';
            }
        });
        
        // Intelligent Life event listeners
        futureFramesInput.addEventListener('input', (e) => {
            FUTURE_FRAMES = parseInt(e.target.value);
            futureValue.textContent = e.target.value;
        });
        
        showGhostCheckbox.addEventListener('change', (e) => {
            SHOW_FUTURE_GHOST = e.target.checked;
        });
        
        // Molecular Bonds event listeners
        bondsCheckbox.addEventListener('change', (e) => {
            enableBonds = e.target.checked;
            bondsOptions.style.display = enableBonds ? 'block' : 'none';
            
            // JeÅ›li wyÅ‚Ä…czamy, reset bonds
            if (!enableBonds) {
                bondCandidates.clear();
                activeBonds = [];
                particles.forEach(p => {
                    p.bonds = [];
                    p.bondSlots = new Array(MAX_BONDS_PER_PARTICLE).fill(false);
                });
                bondsCount.textContent = '0';
            }
        });
        
        bondFormationTime.addEventListener('input', (e) => {
            BOND_FORMATION_TIME = parseInt(e.target.value);
            bondFormationTimeValue.textContent = e.target.value + 's';
        });
        
        bondMaxDistance.addEventListener('input', (e) => {
            BOND_MAX_DISTANCE = parseInt(e.target.value);
            bondMaxDistanceValue.textContent = e.target.value + 'px';
        });
        
        bondMaxBonds.addEventListener('input', (e) => {
            MAX_BONDS_PER_PARTICLE = parseInt(e.target.value);
            bondMaxBondsValue.textContent = e.target.value;
        });
        
        bondLength.addEventListener('input', (e) => {
            BOND_LENGTH = parseInt(e.target.value);
            bondLengthValue.textContent = e.target.value + 'px';
        });
        
        // Life Detection event listeners
        // Life Scanner - Toggle panel (click header or toggle button)
        const toggleScanner = () => {
            enableLifeDetection = !enableLifeDetection;
            
            // Toggle active class
            scannerToggle.classList.toggle('active', enableLifeDetection);
            
            // Show/hide content
            scannerContent.style.display = enableLifeDetection ? 'block' : 'none';
            
            console.log('ğŸ§¬ Life Detection:', enableLifeDetection ? 'WÅÄ„CZONE' : 'WYÅÄ„CZONE');
            
            if (!enableLifeDetection) {
                detectedLifeForms = [];
                lifeFormsCount.textContent = '0';
            }
        };
        
        scannerToggle.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent header click
            toggleScanner();
        });
        
        // Also allow clicking the header
        document.querySelector('.scanner-header').addEventListener('click', toggleScanner);
        
        // Life Scanner - RANGE SLIDERS event listeners
        lifeMinParticlesFrom.addEventListener('input', (e) => {
            let from = parseInt(e.target.value);
            let to = parseInt(lifeMinParticlesTo.value);
            if (from > to) {
                from = to;
                e.target.value = from;
            }
            LIFE_MIN_PARTICLES_FROM = from;
            lifeMinParticlesValue.textContent = `${from}-${to}`;
        });
        
        lifeMinParticlesTo.addEventListener('input', (e) => {
            let to = parseInt(e.target.value);
            let from = parseInt(lifeMinParticlesFrom.value);
            if (to < from) {
                to = from;
                e.target.value = to;
            }
            LIFE_MIN_PARTICLES_TO = to;
            lifeMinParticlesValue.textContent = `${from}-${to}`;
        });
        
        lifeMinColorsFrom.addEventListener('input', (e) => {
            let from = parseInt(e.target.value);
            let to = parseInt(lifeMinColorsTo.value);
            if (from > to) {
                from = to;
                e.target.value = from;
            }
            LIFE_MIN_COLORS_FROM = from;
            lifeMinColorsValue.textContent = `${from}-${to}`;
        });
        
        lifeMinColorsTo.addEventListener('input', (e) => {
            let to = parseInt(e.target.value);
            let from = parseInt(lifeMinColorsFrom.value);
            if (to < from) {
                to = from;
                e.target.value = to;
            }
            LIFE_MIN_COLORS_TO = to;
            lifeMinColorsValue.textContent = `${from}-${to}`;
        });
        
        lifeMaxDistanceFrom.addEventListener('input', (e) => {
            let from = parseInt(e.target.value);
            let to = parseInt(lifeMaxDistanceTo.value);
            if (from > to) {
                from = to;
                e.target.value = from;
            }
            LIFE_MAX_DISTANCE_FROM = from;
            lifeMaxDistanceValue.textContent = `${from}-${to}px`;
        });
        
        lifeMaxDistanceTo.addEventListener('input', (e) => {
            let to = parseInt(e.target.value);
            let from = parseInt(lifeMaxDistanceFrom.value);
            if (to < from) {
                to = from;
                e.target.value = to;
            }
            LIFE_MAX_DISTANCE_TO = to;
            lifeMaxDistanceValue.textContent = `${from}-${to}px`;
        });
        
        lifeMaxSpeedDiffFrom.addEventListener('input', (e) => {
            let from = parseInt(e.target.value);
            let to = parseInt(lifeMaxSpeedDiffTo.value);
            if (from > to) {
                from = to;
                e.target.value = from;
            }
            LIFE_MAX_SPEED_DIFF_FROM = from;
            lifeMaxSpeedDiffValue.textContent = `${from}-${to}`;
        });
        
        lifeMaxSpeedDiffTo.addEventListener('input', (e) => {
            let to = parseInt(e.target.value);
            let from = parseInt(lifeMaxSpeedDiffFrom.value);
            if (to < from) {
                to = from;
                e.target.value = to;
            }
            LIFE_MAX_SPEED_DIFF_TO = to;
            lifeMaxSpeedDiffValue.textContent = `${from}-${to}`;
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // Prawy przycisk (button === 2) - dodaj inteligentnÄ… czÄ…stkÄ™
            if (e.button === 2) {
                e.preventDefault();  // Prevent context menu
                
                // SprawdÅº czy Intelligent Life jest wÅ‚Ä…czone
                if (!intelligentCheckbox.checked) {
                    console.log('âš ï¸ WÅ‚Ä…cz "Intelligent Life" aby dodawaÄ‡ inteligentne czÄ…stki');
                    return false;
                }
                
                // Generuj unikalny kolor dla inteligentnej czÄ…stki
                const hue = (nextIntelligentColor * 137.5) % 360;  // Golden angle
                const intelligentColor = `hsl(${hue}, 80%, 60%)`;
                
                // UtwÃ³rz inteligentnÄ… czÄ…stkÄ™
                const intel = new IntelligentParticle(clickX, clickY, intelligentColor);
                particles.push(intel);
                intelligentParticles.push(intel);
                
                // Aktualizuj licznik
                document.getElementById('intelligentCount').textContent = intelligentParticles.length;
                
                console.log(`ğŸ§  Inteligentna czÄ…stka #${intelligentParticles.length} dodana na (${Math.floor(clickX)}, ${Math.floor(clickY)})`);
                
                return false;
            }
            
            // Lewy przycisk - normalnie (przyciÄ…ganie)
            mousePressed = true;
            mouseX = clickX;
            mouseY = clickY;
        });
        
        // Prevent context menu na canvas
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });

        canvas.addEventListener('mouseup', () => {
            mousePressed = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mousePressed = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mousePressed) {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            }
        });

        // INTERACTION MATRIX GENERATOR
        function generateInteractionMatrixUI() {
            if (!interactionMatrixDiv) return;
            
            interactionMatrixDiv.innerHTML = '';
            
            const colorNames = COLORS.slice(0, SPECIES_COUNT).map(c => c.name);
            
            // NAGÅÃ“WEK ROW 1: Pusta + "X (TO â†’)" + nazwy kolorÃ³w
            const cornerCell = document.createElement('div');
            cornerCell.className = 'matrix-cell matrix-corner';
            cornerCell.innerHTML = '<div style="font-size: 9px; color: #666;">Yâ†“ / Xâ†’</div>';
            interactionMatrixDiv.appendChild(cornerCell);
            
            // Nazwy kolumn (TO - gdzie idzie siÅ‚a)
            colorNames.forEach(name => {
                const headerCell = document.createElement('div');
                headerCell.className = 'matrix-cell matrix-header-col';
                const colorObj = COLORS.find(c => c.name === name);
                headerCell.innerHTML = `<div style="color: ${colorObj.hex}; font-weight: 700;">${name.substring(0, 4).toUpperCase()}</div><div style="font-size: 8px; color: #666;">TOâ†’</div>`;
                interactionMatrixDiv.appendChild(headerCell);
            });
            
            // WIERSZE Z DANYMI
            colorNames.forEach(fromColor => {
                // Label wiersza (FROM - skÄ…d idzie siÅ‚a)
                const rowLabel = document.createElement('div');
                rowLabel.className = 'matrix-cell matrix-header-row';
                const colorObj = COLORS.find(c => c.name === fromColor);
                rowLabel.innerHTML = `<div style="color: ${colorObj.hex}; font-weight: 700;">${fromColor.substring(0, 4).toUpperCase()}</div><div style="font-size: 8px; color: #666;">FROM</div>`;
                interactionMatrixDiv.appendChild(rowLabel);
                
                // KomÃ³rki z inputami (FROM â†’ TO)
                colorNames.forEach(toColor => {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell matrix-data';
                    
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'matrix-input';
                    input.min = '-1.0';
                    input.max = '1.0';
                    input.step = '0.1';
                    input.value = (INTERACTION_MATRIX[fromColor]?.[toColor] || 0).toFixed(1);
                    input.dataset.from = fromColor;
                    input.dataset.to = toColor;
                    input.title = `${fromColor} â†’ ${toColor}`;
                    
                    // Highlight diagonal (self-interaction)
                    if (fromColor === toColor) {
                        cell.style.background = 'rgba(131, 56, 236, 0.1)';
                    }
                    
                    // Update matrix on change
                    input.addEventListener('change', (e) => {
                        const val = parseFloat(e.target.value);
                        const clamped = Math.max(-1.0, Math.min(1.0, val));
                        e.target.value = clamped.toFixed(1);
                        
                        if (!INTERACTION_MATRIX[fromColor]) {
                            INTERACTION_MATRIX[fromColor] = {};
                        }
                        INTERACTION_MATRIX[fromColor][toColor] = clamped;
                        
                        console.log(`ğŸ“Š Matrix updated: ${fromColor} â†’ ${toColor} = ${clamped}`);
                    });
                    
                    cell.appendChild(input);
                    interactionMatrixDiv.appendChild(cell);
                });
            });
        }
        
        // COLOR PROPERTIES TABLE GENERATOR
        function generateColorPropertiesTable() {
            if (!colorPropertiesTable) return;
            
            colorPropertiesTable.innerHTML = '';
            
            // Header row
            const headerRow = document.createElement('div');
            headerRow.className = 'props-row';
            
            const headers = ['Color', 'Charge', 'Mass', 'Range', 'Vorticness'];
            headers.forEach(text => {
                const cell = document.createElement('div');
                cell.className = 'props-header';
                cell.textContent = text;
                headerRow.appendChild(cell);
            });
            colorPropertiesTable.appendChild(headerRow);
            
            // Data rows
            COLORS.slice(0, SPECIES_COUNT).forEach(color => {
                const row = document.createElement('div');
                row.className = 'props-row';
                
                // Color name
                const nameCell = document.createElement('div');
                nameCell.className = 'props-cell color-name';
                nameCell.textContent = color.name.toUpperCase();
                nameCell.style.color = color.hex;
                row.appendChild(nameCell);
                
                // Charge
                const chargeCell = document.createElement('div');
                chargeCell.className = 'props-cell ' + (color.charge > 0 ? 'positive' : (color.charge < 0 ? 'negative' : ''));
                chargeCell.textContent = color.charge > 0 ? '+1' : (color.charge < 0 ? '-1' : '0');
                row.appendChild(chargeCell);
                
                // Mass
                const massCell = document.createElement('div');
                massCell.className = 'props-cell';
                massCell.textContent = color.mass.toFixed(2);
                row.appendChild(massCell);
                
                // Interaction Range
                const rangeCell = document.createElement('div');
                rangeCell.className = 'props-cell';
                rangeCell.textContent = color.interactionRange + 'px';
                row.appendChild(rangeCell);
                
                // Vorticness
                const vorticnessCell = document.createElement('div');
                vorticnessCell.className = 'props-cell';
                vorticnessCell.textContent = color.vorticness.toFixed(2);
                row.appendChild(vorticnessCell);
                
                colorPropertiesTable.appendChild(row);
            });
        }
        
        // Toggle matrix visibility
        if (editMatrixBtn) {
            editMatrixBtn.addEventListener('click', () => {
                const isVisible = interactionMatrixContainer.style.display !== 'none';
                
                if (isVisible) {
                    interactionMatrixContainer.style.display = 'none';
                    editMatrixBtn.textContent = 'ğŸ“Š Edit Interaction Matrix';
                } else {
                    generateInteractionMatrixUI();
                    interactionMatrixContainer.style.display = 'block';
                    editMatrixBtn.textContent = 'âœ• Close Matrix';
                }
            });
        }
        
        // Toggle color properties visibility
        if (viewPropertiesBtn) {
            viewPropertiesBtn.addEventListener('click', () => {
                const isVisible = colorPropertiesContainer.style.display !== 'none';
                
                if (isVisible) {
                    colorPropertiesContainer.style.display = 'none';
                    viewPropertiesBtn.textContent = 'ğŸ¨ View Color Properties';
                } else {
                    generateColorPropertiesTable();
                    colorPropertiesContainer.style.display = 'block';
                    viewPropertiesBtn.textContent = 'âœ• Close Properties';
                }
            });
        }

        async function init() {
            try {
                await document.fonts.ready;
            } catch (e) {}
            
            initParticles();
            ctx.fillStyle = '#0a0a14';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            currentSeedDisplay.textContent = 'DomyÅ›lne';
            
            updateButtonState();
            drawStatusAndFPS();
            
            console.log('âœ… Petrie Dish v2.22.0 - RANGE SLIDERS EDITION!');
            console.log('ğŸšï¸ LIFE SCANNER: RANGE SLIDERS (from-to)!');
            console.log('   â€¢ PARTICLES: 3-100 range (dual sliders!)');
            console.log('   â€¢ COLORS: 1-16 range (detect diversity!)');
            console.log('   â€¢ DISTANCE: 5-100px range (precise control!)');
            console.log('   â€¢ VELOCITY: 1-10 range (movement sync!)');
            console.log('ğŸš€ 1000 particles default (3.3x baseline!)');
            console.log('ğŸ’¡ Full control: Detect life in specific ranges!');
            console.log('ğŸ¯ Example: particles 5-20, colors 3-6, distance 20-40px');
        }
        
        init();
    </script>
</body>
</html>